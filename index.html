<!DOCTYPE html>
<html lang="en">
<head>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Question Bank with Image Uploads</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 15px;
            line-height: 1.5;
            color: #333;
            font-size: 16px;
        }
        .header {
            display: flex;
            flex-direction: column;
            margin-bottom: 20px;
        }
        .panel {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        textarea, input, select {
            width: 100%;
            padding: 10px;
            margin-bottom: 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: inherit;
            font-size: 16px;
            box-sizing: border-box;
        }
        textarea {
            min-height: 120px;
            resize: vertical;
        }
        button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin-right: 8px;
            margin-bottom: 8px;
            transition: background-color 0.3s;
            width: auto
        }
        button:hover {
            background-color: #45a049;
        }
        button.danger {
            background-color: #f44336;
        }
        button.secondary {
            background-color: #2196F3;
        }
        .question {
            border: 1px solid #ddd;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 8px;
            background-color: white;
            position: relative;
        }
        .correct {
            font-weight: bold;
            color: #2e7d32;
        }
        .metadata {
            color: #666;
            font-size: 0.9em;
            margin-bottom: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        .metadata span {
            background: #e3f2fd;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.8em;
        }
        .actions {
            display: flex;
            gap: 8px;
            margin-top: 15px;
            justify-content: flex-end;
        }
        .actions button {
            padding: 8px 12px;
            font-size: 14px;
        }
        .options-list {
            list-style-type: none;
            padding-left: 0;
            margin-top: 10px;
        }
        .options-list li {
            padding: 5px 0;
        }
        .search-filters {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 15px;
        }
        .tab-container {
            display: flex;
            margin-bottom: 15px;
            overflow-x: auto;
            white-space: nowrap;
            padding-bottom: 5px;
        }
        .tab {
            padding: 10px 15px;
            cursor: pointer;
            background: #e0e0e0;
            border-radius: 5px;
            margin-right: 5px;
            display: inline-block;
            font-size: 14px;
        }
        .tab.active {
            background: #4CAF50;
            color: white;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .stats {
            display: flex;
            justify-content: space-between;
            background: #e3f2fd;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 10px;
        }
        .stat-item {
            text-align: center;
            min-width: 80px;
        }
        .stat-value {
            font-size: 20px;
            font-weight: bold;
            color: #0d47a1;
        }
        .image-upload-container {
            margin: 15px 0;
        }
        .image-preview {
            max-width: 100%;
            max-height: 200px;
            margin-top: 10px;
            display: none;
        }
        .option-image-upload {
            display: flex;
            flex-direction: column;
            margin-top: 5px;
        }
        .option-image-preview {
            max-width: 100%;
            max-height: 150px;
            margin-top: 5px;
            display: none;
        }
        /* New classes for type-specific forms */
        .cq-only, .sq-only {
            display: none; /* Hidden by default */
        }
        .mcq-only {
            display: block; /* Shown by default */
        }

        /* When editing/adding a CQ, show CQ-only fields and hide others */
        .editing-cq .cq-only {
            display: block;
        }
        .editing-cq .mcq-only,
        .editing-cq .sq-only {
            display: none;
        }

        /* When editing/adding an MCQ, show MCQ-only fields and hide others */
        .editing-mcq .mcq-only {
            display: block;
        }
        .editing-mcq .cq-only,
        .editing-mcq .sq-only {
            display: none;
        }

        /* When editing/adding an SQ, show SQ-only fields and hide others */
        .editing-sq .sq-only {
            display: block;
        }
        .editing-sq .mcq-only,
        .editing-sq .cq-only {
            display: none;
        }

        .option-fields div {
            margin-bottom: 15px;
        }
        .part-marks {
            width: 80px;
            margin-top: 5px;
        }
        .part-answer {
            min-height: 80px;
            margin-top: 5px;
        }
        @media (min-width: 768px) {
            body {
                max-width: 1200px;
                margin: 0 auto;
                padding: 20px;
            }
            .header {
                flex-direction: row;
                justify-content: space-between;
                align-items: center;
            }
            .search-filters {
                flex-direction: row;
                flex-wrap: wrap;
            }
            .search-filters > div {
                flex: 1;
                min-width: 150px;
            }
            .tab-container {
                white-space: normal;
                flex-wrap: wrap;
            }
        }
        .format-example {
            margin: 15px 0;
            overflow: hidden;
        }
        .format-example pre {
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-x: auto;
            background: #f5f5f5;
            padding: 15px;
            border-radius: 4px;
            max-height: 300px;
            font-family: monospace;
            line-height: 1.4;
            border: 1px solid #ddd;
        }
        #cqInput, #sqInput {
            width: 100%;
            min-height: 200px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: inherit;
            resize: vertical;
            margin-top: 10px;
        }
        .button-group {
            margin: 15px 0;
            display: flex;
            gap: 10px;
        }
        @media (max-width: 768px) {
            .format-example pre {
                font-size: 14px;
                padding: 10px;
            }
            #cqInput, #sqInput {
                min-height: 150px;
            }
        }
        .metadata-fields {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }
        .metadata-fields div {
            display: flex;
            flex-direction: column;
        }
        .metadata-fields label {
            margin-bottom: 5px;
            font-weight: 500;
            color: #555;
        }
        .metadata-fields input[type="text"] {
            padding: 8px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        .metadata-fields input[type="checkbox"] {
            width: auto;
            margin-top: 5px;
        }
        .detailed-stats {
            margin-top: 20px;
            padding: 15px;
            background: #f0f4f7;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .detailed-stats h3 {
            margin-top: 0;
            color: #0d47a1;
        }
        .detailed-stats ul {
            list-style: none;
            padding: 0;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        .detailed-stats li {
            background: #e3f2fd;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.9em;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .detailed-stats li strong {
            color: #333;
        }
        /* New class for SQ specific answer textarea */
        .sq-answer {
            min-height: 100px;
            margin-top: 5px;
        }
        /* Password Overlay Styles */
        .password-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .password-prompt {
            background-color: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            text-align: center;
        }
        .password-prompt input {
            margin: 15px 0;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 200px;
        }
        .password-prompt button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .mcq-example {
            white-space: pre-wrap; /* Ensures text wraps to the next line */
            word-wrap: break-word; /* Breaks long words to prevent overflow */
            max-width: 100%; /* Keeps content within the parent container */
            overflow-x: auto; /* Adds horizontal scrollbar if needed */
            background-color: #f8f8f8; /* Light background for readability */
            padding: 15px; /* Matches existing panel padding */
            border-radius: 5px; /* Matches existing panel styling */
            font-size: 14px; /* Matches input field font size */
            line-height: 1.5; /* Improves readability */
        }

    </style>
</head>
<body>
    <div id="password-overlay" class="password-overlay">
        <div class="password-prompt">
            <h2>Enter Password</h2>
            <input type="password" id="password-input" placeholder="Password">
            <button id="password-submit">Submit</button>
        </div>
    </div>

    <div class="header">
        <h1>Advanced Question Bank with Images</h1>
        <div>
            <button id="exportBtn" class="secondary">Export All</button>
            <button id="importBtn" class="secondary">Import JSON</button>
        </div>
    </div>

    <div class="tab-container">
        <div class="tab active" data-tab="import">Import Questions</div>
        <div class="tab" data-tab="bank">Question Bank</div>
        <div class="tab" data-tab="add">Add New Question</div>
        <div class="tab" data-tab="cq">Import CQ</div>
        <div class="tab" data-tab="sq">Import SQ</div>
    </div>

    <div class="tab-content active" id="import-tab">
        <div class="panel">
            <h2>Bulk Import Questions</h2>
            <p>Format your questions like this:</p>
          <pre class="mcq-example">
[Subject: Math]
[Chapter: Algebra]
[Lesson: Linear Equations]
[Board: CBSE]
[isQuizzable: true
[Tags: easy, calculation]
1. What is the solution to 2x + 3 = 7?
a) 1
b) 2
c) 3
d) 4
Correct: b
Explanation: To solve 2x + 3 = 7, subtract 3 from both sides to get 2x = 4, then divide by 2 to find x = 2. Thus, the correct answer is option b.
                        </pre>

            <textarea id="mcqInput" placeholder="Paste your questions here..."></textarea>
            <button id="parseBtn">Parse Questions</button>
            <button id="clearImportBtn" class="danger">Clear</button>
        </div>
    </div>

    <div class="tab-content" id="bank-tab">
        <div class="panel">
            <h2>Question Bank</h2>
            <div class="stats">
                <div class="stat-item">
                    <div class="stat-value" id="totalQuestions">0</div>
                    <div>Total Questions</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="subjectsCount">0</div>
                    <div>Subjects</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="chaptersCount">0</div>
                    <div>Chapters</div>
                </div>
            </div>

            <div class="detailed-stats">
                <h3>Detailed Counts</h3>
                <div id="detailedStatsContent">
                    </div>
            </div>
            <div class="search-filters">
                <div>
                    <label for="searchText">Search Text:</label>
                    <input type="text" id="searchText" placeholder="Enter keywords...">
                </div>
                <div>
                    <label for="filterSubject">Subject:</label>
                    <select id="filterSubject">
                        <option value="">All Subjects</option>
                    </select>
                </div>
                <div>
                    <label for="filterChapter">Chapter:</label>
                    <select id="filterChapter">
                        <option value="">All Chapters</option>
                    </select>
                </div>
                <div>
                    <label for="filterLesson">Lesson:</label>
                    <select id="filterLesson">
                        <option value="">All Lessons</option>
                    </select>
                </div>
                <div>
                    <label for="filterType">Type:</label>
                    <select id="filterType">
                        <option value="">All Types</option>
                        <option value="mcq">MCQ</option>
                        <option value="cq">CQ</option>
                        <option value="sq">SQ</option> </select>
                </div>
                <div>
                    <label for="filterBoard">Board:</label>
                    <select id="filterBoard">
                        <option value="">All Boards</option>
                    </select>
                </div>
                <div>
                    <label for="filterQuizzable">Quizzable:</label>
                    <select id="filterQuizzable">
                        <option value="">All</option>
                        <option value="true">Quizzable</option>
                        <option value="false">Non-Quizzable</option>
                    </select>
                </div>
            </div>
            <button id="applyFiltersBtn">Apply Filters</button>
            <button id="resetFiltersBtn" class="secondary">Reset Filters</button>
            <div id="questionsContainer"></div>
        </div>
    </div>

    <div class="tab-content" id="add-tab">
        <div class="panel">
            <h2>Add/Edit Question</h2>
            <input type="hidden" id="editQuestionId">
            <div>
                <label for="questionType">Question Type:</label>
                <select id="questionType">
                    <option value="mcq">MCQ</option>
                    <option value="cq">CQ</option>
                    <option value="sq">SQ</option> </select>
            </div>
            <div class="metadata-fields">
                <div>
                    <label for="subject">Subject:</label>
                    <input type="text" id="subject" placeholder="e.g., Mathematics">
                </div>
                <div>
                    <label for="chapter">Chapter:</label>
                    <input type="text" id="chapter" placeholder="e.g., Algebra">
                </div>
                <div>
                    <label for="lesson">Lesson:</label>
                    <input type="text" id="lesson" placeholder="e.g., Linear Equations">
                </div>
                <div>
                    <label for="board">Board:</label>
                    <input type="text" id="board" placeholder="e.g., DB24, JB21, SB20">
                </div>
                <div>
                    <label for="isQuizzable">Quizzable:</label>
                    <input type="checkbox" id="isQuizzable" checked>
                    <span style="margin-left: 5px; font-size: 0.9em;">(Include in quizzes?)</span>
                </div>
            </div>
            <div>
                <label for="questionText">Question:</label>
                <textarea id="questionText" placeholder="Enter your question here..."></textarea>
            </div>
            <div class="image-upload-container">
                <label for="questionImageUpload">Question Image:</label>
                <input type="file" id="questionImageUpload" accept="image/*">
                <img id="questionImagePreview" class="image-preview">
                <button id="removeQuestionImageBtn" class="danger" style="display: none; margin-top: 5px;">Remove Image</button>
            </div>

            <div class="mcq-only">
                <div>
                    <label>Options:</label>
                    <div class="option-fields">
                        <div>
                            <input type="text" class="option" placeholder="Option a)" data-option="a">
                            <div class="option-image-upload">
                                <label>Image for a:</label>
                                <input type="file" class="option-image-upload-input" data-option="a" accept="image/*">
                                <img class="option-image-preview" data-option="a">
                                <button class="remove-option-image-btn danger" data-option="a" style="display: none; margin-top: 5px;">Remove</button>
                            </div>
                        </div>
                        <div>
                            <input type="text" class="option" placeholder="Option b)" data-option="b">
                            <div class="option-image-upload">
                                <label>Image for b:</label>
                                <input type="file" class="option-image-upload-input" data-option="b" accept="image/*">
                                <img class="option-image-preview" data-option="b">
                                <button class="remove-option-image-btn danger" data-option="b" style="display: none; margin-top: 5px;">Remove</button>
                            </div>
                        </div>
                        <div>
                            <input type="text" class="option" placeholder="Option c)" data-option="c">
                            <div class="option-image-upload">
                                <label>Image for c:</label>
                                <input type="file" class="option-image-upload-input" data-option="c" accept="image/*">
                                <img class="option-image-preview" data-option="c">
                                <button class="remove-option-image-btn danger" data-option="c" style="display: none; margin-top: 5px;">Remove</button>
                            </div>
                        </div>
                        <div>
                            <input type="text" class="option" placeholder="Option d)" data-option="d">
                            <div class="option-image-upload">
                                <label>Image for d:</label>
                                <input type="file" class="option-image-upload-input" data-option="d" accept="image/*">
                                <img class="option-image-preview" data-option="d">
                                <button class="remove-option-image-btn danger" data-option="d" style="display: none; margin-top: 5px;">Remove</button>
                            </div>
                        </div>
                    </div>
                </div>
                <label for="correctAnswer">Correct Answer:</label>
                <select id="correctAnswer">
                    <option value="">Select correct answer</option>
                    <option value="a">Option a</option>
                    <option value="b">Option b</option>
                    <option value="c">Option c</option>
                    <option value="d">Option d</option>
                </select>
                <div>
                    <label for="explanation">Explanation:</label>
                    <textarea id="explanation" placeholder="Enter the explanation for the correct answer..."></textarea>
                </div>
            </div>

            <div class="cq-only">
                <div>
                    <label>Parts:</label>
                    <div class="option-fields">
                        <div>
                            <input type="text" class="option" placeholder="Part a) text" data-option="a">
                            <input type="number" class="part-marks" placeholder="Marks" data-option="a" min="0">
                            <textarea class="part-answer" placeholder="Answer for part a" data-option="a"></textarea>
                            <div class="option-image-upload">
                                <label>Image for a:</label>
                                <input type="file" class="option-image-upload-input" data-option="a" accept="image/*">
                                <img class="option-image-preview" data-option="a">
                                <button class="remove-option-image-btn danger" data-option="a" style="display: none; margin-top: 5px;">Remove</button>
                            </div>
                        </div>
                        <div>
                            <input type="text" class="option" placeholder="Part b) text" data-option="b">
                            <input type="number" class="part-marks" placeholder="Marks" data-option="b" min="0">
                            <textarea class="part-answer" placeholder="Answer for part b" data-option="b"></textarea>
                            <div class="option-image-upload">
                                <label>Image for b:</label>
                                <input type="file" class="option-image-upload-input" data-option="b" accept="image/*">
                                <img class="option-image-preview" data-option="b">
                                <button class="remove-option-image-btn danger" data-option="b" style="display: none; margin-top: 5px;">Remove</button>
                            </div>
                        </div>
                        <div>
                            <input type="text" class="option" placeholder="Part c) text" data-option="c">
                            <input type="number" class="part-marks" placeholder="Marks" data-option="c" min="0">
                            <textarea class="part-answer" placeholder="Answer for part c" data-option="c"></textarea>
                            <div class="option-image-upload">
                                <label>Image for c:</label>
                                <input type="file" class="option-image-upload-input" data-option="c" accept="image/*">
                                <img class="option-image-preview" data-option="c">
                                <button class="remove-option-image-btn danger" data-option="c" style="display: none; margin-top: 5px;">Remove</button>
                            </div>
                        </div>
                        <div>
                            <input type="text" class="option" placeholder="Part d) text" data-option="d">
                            <input type="number" class="part-marks" placeholder="Marks" data-option="d" min="0">
                            <textarea class="part-answer" placeholder="Answer for part d" data-option="d"></textarea>
                            <div class="option-image-upload">
                                <label>Image for d:</label>
                                <input type="file" class="option-image-upload-input" data-option="d" accept="image/*">
                                <img class="option-image-preview" data-option="d">
                                <button class="remove-option-image-btn danger" data-option="d" style="display: none; margin-top: 5px;">Remove</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="sq-only">
                <div>
                    <label for="sqAnswer">Answer:</label>
                    <textarea id="sqAnswer" class="sq-answer" placeholder="Enter the answer to the short question here..."></textarea>
                </div>
            </div>

            <div>
                <label for="tags">Tags (comma separated):</label>
                <input type="text" id="tags" placeholder="e.g., easy, formula, calculation">
            </div>
            <button id="saveQuestionBtn">Save Question</button>
            <button id="cancelEditBtn" class="danger" style="display:none;">Cancel Edit</button>
        </div>
    </div>

    <div class="tab-content" id="cq-tab">
        <div class="panel">
            <h2>Bulk Import Constructive Questions (CQ)</h2>
            <p>Format your questions like this example:</p>
            <div class="format-example">
                <pre style="white-space: pre-wrap; word-wrap: break-word; overflow-x: auto; background: #f5f5f5; padding: 15px; border-radius: 4px; max-height: 300px;">
Question 1
[There is a picture]
Organelle M and N are marked in the diagram.
a. What is plasmalemma? (1)
b. Why are plastids called colour forming organs? (2)
c. Why is the organelle marked with N important for the living world? Explain. (3)
d. What types of problem will appear in living bodies if the part marked with M is absent? Analyse it. (4)

Answer:
a. The protoplasm of the living cell remains surrounded by a bilayered selectively permeable membrane known as plasmalemma or cell membrane.
b. The coloured organelles present within the cytoplasm of plant cells are known as plastids. They are responsible for the formation of colour of any plant part like leaves, flower and fruits. In absence of light plastids become colourless.
c. The N marked organelle is the chloroplast. Plants trap light energy by the chloroplast to manufacture carbohydrate food, releasing oxygen. This maintains oxygen balance and provides energy for living organisms.
d. The M-marked part is the centriole. If absent, cell division in animals would stop, halting growth and development as chromatids cannot separate during mitosis.
Subject: Biology
Chapter: Cell Structure and Function
Lesson: Organelles and Their Roles
Board: CBSE
isQuizzable: true
Tags: cell, organelle
                </pre>
            </div>
            <textarea id="cqInput" placeholder="Paste your CQ questions here..."></textarea>
            <div class="button-group">
                <button id="parseCqBtn" style="margin-top: 10px;">Parse CQ Questions</button>
                <button id="clearCqBtn" class="danger" style="margin-top: 10px;">Clear</button>
            </div>
        </div>
    </div>

    <div class="tab-content" id="sq-tab">
        <div class="panel">
            <h2>Bulk Import Short Questions (SQ)</h2>
            <p>Format your questions like this example:</p>
            <div class="format-example">
                <pre style="white-space: pre-wrap; word-wrap: break-word; overflow-x: auto; background: #f5f5f5; padding: 15px; border-radius: 4px; max-height: 300px;">
[Subject: Physics]  
[Chapter: Laws of Motion]  
[Lesson: Newton's First Law]  
[isQuizzable: true]  
[Board: DB24]
[Tags: fundamental, theory]  

1. What does Newton's First Law of Motion state?  
Answer: Newton's First Law, also called the Law of Inertia, states that an object at rest will remain at rest, and an object in motion will continue moving at a constant velocity in a straight line, unless acted upon by an external unbalanced force. This law introduces the concept of inertia as a property of matter that resists changes to its state of motion.
                </pre>
            </div>
            <textarea id="sqInput" placeholder="Paste your SQ questions here..."></textarea>
            <div class="button-group">
                <button id="parseSqBtn" style="margin-top: 10px;">Parse SQ Questions</button>
                <button id="clearSqBtn" class="danger" style="margin-top: 10px;">Clear</button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', async function() {
            const CORRECT_PASSWORD = 'EdVenture';
            const passwordOverlay = document.getElementById('password-overlay');
            const passwordInput = document.getElementById('password-input');
            const passwordSubmit = document.getElementById('password-submit');

            passwordSubmit.addEventListener('click', function() {
                if (passwordInput.value === CORRECT_PASSWORD) {
                    passwordOverlay.style.display = 'none';
                    initializeApplication(); // Proceed with app initialization
                } else {
                    alert('Incorrect password. Please try again.');
                    passwordInput.value = '';
                }
            });

            passwordInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    passwordSubmit.click();
                }
            });

            // ======================
            // 1. SUPABASE INIT (MUST BE FIRST)
            // Your Supabase init code here
            const createClient = supabase.createClient;

            // ✅ Use hardcoded keys in frontend (Replit doesn't support process.env in browser)
            const supabaseUrl = 'https://idgogbisqacywbfnhdzy.supabase.co';  // Replace this with your Supabase URL
            const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImlkZ29nYmlzcWFjeXdiZm5oZHp5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTIzMjAxODMsImV4cCI6MjA2Nzg5NjE4M30.vPUQowhkQVLcQQziELxvLt3cz0QO8cBonxQwIYcjJHs';                        // Replace this with your Supabase Public Key (anon)
            let supabaseClient = null;
            const BUCKET_NAME = 'questionimages'; // <<<<<<<<<<<<<<<< MAKE SURE THIS MATCHES YOUR BUCKET NAME

            async function initSupabase() {
                try {
                    console.log("Attempting to connect to Supabase...");
                    supabaseClient = createClient(supabaseUrl, supabaseKey);

                    // Test the connection
                    const { data, error } = await supabaseClient.from('questions').select('*').limit(1);
                    if (error) throw error;

                    console.log("✅ Supabase connection test successful!");
                    return true;
                } catch (err) {
                    console.warn("❌ Supabase connection failed:", err.message);
                    alert('Failed to connect to Supabase: ' + err.message);
                    supabaseClient = null;
                    return false;
                }
            }

            // ======================
            // 2. ALL OTHER EXISTING CODE BELOW
            // ======================
            const CHUNK_SIZE = 20; // Number of questions to process at once
            const tabs = document.querySelectorAll('.tab');
            const tabContents = document.querySelectorAll('.tab-content');
            const mcqInput = document.getElementById('mcqInput');
            const parseBtn = document.getElementById('parseBtn');
            const clearImportBtn = document.getElementById('clearImportBtn');
            const questionsContainer = document.getElementById('questionsContainer');
            const searchText = document.getElementById('searchText');
            const filterSubject = document.getElementById('filterSubject');
            const filterChapter = document.getElementById('filterChapter');
            const filterLesson = document.getElementById('filterLesson');
            const filterType = document.getElementById('filterType');
            const filterBoard = document.getElementById('filterBoard');
            const filterQuizzable = document.getElementById('filterQuizzable');
            const applyFiltersBtn = document.getElementById('applyFiltersBtn');
            const resetFiltersBtn = document.getElementById('resetFiltersBtn');
            const saveQuestionBtn = document.getElementById('saveQuestionBtn');
            const cancelEditBtn = document.getElementById('cancelEditBtn');
            const exportBtn = document.getElementById('exportBtn');
            const importBtn = document.getElementById('importBtn');
            const editQuestionId = document.getElementById('editQuestionId');
            const questionType = document.getElementById('questionType');
            const subjectInput = document.getElementById('subject');
            const chapterInput = document.getElementById('chapter');
            const lessonInput = document.getElementById('lesson');
            const boardInput = document.getElementById('board');
            const isQuizzableInput = document.getElementById('isQuizzable');
            const questionTextInput = document.getElementById('questionText');
            const optionInputs = document.querySelectorAll('.option');
            const correctAnswerSelect = document.getElementById('correctAnswer');
            const tagsInput = document.getElementById('tags');
            const questionImageUpload = document.getElementById('questionImageUpload');
            const questionImagePreview = document.getElementById('questionImagePreview');
            const removeQuestionImageBtn = document.getElementById('removeQuestionImageBtn');
            const optionImageUploadInputs = document.querySelectorAll('.option-image-upload-input');
            const optionImagePreviews = document.querySelectorAll('.option-image-preview');
            const removeOptionImageBtns = document.querySelectorAll('.remove-option-image-btn');
            const totalQuestionsEl = document.getElementById('totalQuestions');
            const subjectsCountEl = document.getElementById('subjectsCount');
            const chaptersCountEl = document.getElementById('chaptersCount');
            const cqInput = document.getElementById('cqInput');
            const parseCqBtn = document.getElementById('parseCqBtn');
            const clearCqBtn = document.getElementById('clearCqBtn');
            const detailedStatsContent = document.getElementById('detailedStatsContent');
            const sqInput = document.getElementById('sqInput');
            const parseSqBtn = document.getElementById('parseSqBtn');
            const clearSqBtn = document.getElementById('clearSqBtn');
            const sqAnswerInput = document.getElementById('sqAnswer');
            const explanationInput = document.getElementById('explanation');

            let questionBank = [];
            let currentFilters = {};

            function initializeApplication() {
                // Check if critical elements exist
                const criticalElements = [
                    'mcqInput', 'parseBtn', 'questionsContainer', 'saveQuestionBtn',
                    'questionType', 'questionText', 'totalQuestions', 'board', 'isQuizzable',
                    'detailedStatsContent', 'sqInput', 'parseSqBtn', 'sqAnswer'
                ];

                for (const elementId of criticalElements) {
                    if (!document.getElementById(elementId)) {
                        console.error(`Critical element missing: ${elementId}`);
                        alert(`Error: Missing element with ID '${elementId}'. Please check your HTML.`);
                        return;
                    }
                }

                // Set form type (MCQ, CQ or SQ)
                function setFormType(type) {
                    const panel = document.querySelector('#add-tab .panel');
                    panel.classList.remove('editing-mcq', 'editing-cq', 'editing-sq');
                    panel.classList.add(`editing-${type}`);
                }

                tabs.forEach(tab => {
                    tab.addEventListener('click', (e) => {
                        e.preventDefault();
                        const tabName = tab.dataset.tab;

                        // Remove active class from all tabs and contents
                        tabs.forEach(t => t.classList.remove('active'));
                        tabContents.forEach(content => content.classList.remove('active'));

                        // Add active class to clicked tab and corresponding content
                        tab.classList.add('active');
                        const targetContent = document.getElementById(`${tabName}-tab`);
                        if (targetContent) {
                            targetContent.classList.add('active');
                        }
                    });
                });

                // Load questions (Supabase only)

                // Save questions (Supabase only)
                async function loadQuestions() {
                    if (!supabaseClient) {
                        console.error('Supabase client not available. Cannot load questions.');
                        alert('Supabase is not connected. Cannot load questions from the database.');
                        return [];
                    }

                    try {
                        const { data, error } = await supabaseClient
                            .from('questions')
                            .select('*')
                            .order('created_at', { ascending: false });
                        if (error) throw error;

                        // Map Supabase fields to local question object structure
                        const loadedQuestions = data.map(q => ({
                            ...q,
                            synced: true,
                            // Map snake_case to camelCase for consistency
                            correctAnswer: q.correct_answer || null, // Map correct_answer to correctAnswer
                            question: q.type === 'cq' ? q.question_text : q.question, // Handle CQ question_text
                            questionText: q.type === 'cq' ? q.question_text : null,
                            isQuizzable: q.is_quizzable !== false,
                            options: q.options || null,
                            parts: q.parts || null,
                            answer: q.answer || null,
                            explanation: q.explanation || null,
                            image: q.image || null,
                            answerimage1: q.answerimage1 || null,
                            answerimage2: q.answerimage2 || null,
                            tags: q.tags || []
                        }));

                        console.log('Loaded questions from Supabase:', loadedQuestions.length);
                        return loadedQuestions;
                    } catch (error) {
                        console.error('Error loading from Supabase:', error);
                        alert('Failed to load questions from Supabase. Please check your network connection or Supabase configuration.');
                        return [];
                    }
                }

                // --- Supabase Image Upload Function ---
                async function uploadImage(file, path) {
                    if (!supabaseClient) {
                        console.warn('Supabase client not initialized. Cannot upload image.');
                        alert('Supabase is not connected. Image upload failed.');
                        return null;
                    }

                    const fileName = `${Date.now()}-${file.name.replace(/\s/g, '_')}`;
                    const filePath = `${path}/${fileName}`;

                    try {
                        const { data, error } = await supabaseClient.storage
                            .from(BUCKET_NAME)
                            .upload(filePath, file, {
                                cacheControl: '3600',
                                upsert: false // Set to true if you want to overwrite existing files with the same name
                            });

                        if (error) {
                            console.error('Error uploading image:', error);
                            throw error;
                        }

                        // Get public URL
                        const { data: publicUrlData } = supabaseClient.storage
                            .from(BUCKET_NAME)
                            .getPublicUrl(filePath);

                        if (publicUrlData && publicUrlData.publicUrl) {
                            console.log('Image uploaded successfully:', publicUrlData.publicUrl);
                            return publicUrlData.publicUrl;
                        } else {
                            console.error('Failed to get public URL:', publicUrlData);
                            throw new Error('Failed to retrieve public URL after upload.');
                        }
                    } catch (error) {
                        console.error('Supabase Storage upload error:', error.message);
                        alert(`Error uploading image: ${error.message}`);
                        return null;
                    }
                }

                // --- Supabase Image Deletion Function ---
                async function deleteImage(url) {
                    if (!supabaseClient || !url || !url.includes(BUCKET_NAME)) {
                        console.warn('Supabase client not initialized or invalid URL for deletion.');
                        return;
                    }

                    try {
                        // Extract the path within the bucket from the public URL
                        const pathParts = url.split(BUCKET_NAME + '/public/');
                        if (pathParts.length < 2) {
                            console.warn('Could not extract valid path from image URL for deletion:', url);
                            return;
                        }
                        const filePath = pathParts[1];

                        const { data, error } = await supabaseClient.storage
                            .from(BUCKET_NAME)
                            .remove([filePath]);

                        if (error) {
                            console.error('Error deleting image from Supabase Storage:', error);
                            throw error;
                        }
                        console.log('Image deleted from Supabase Storage:', filePath, data);
                    } catch (error) {
                        console.error('Supabase Storage deletion error:', error.message);
                        alert(`Error deleting image: ${error.message}`); // Inform user about deletion failure
                    }
                }

                // Function to check for duplicates
                function isDuplicateQuestion(newQuestion) {
                    return questionBank.some(existingQuestion => {
                        if (existingQuestion.type !== newQuestion.type) {
                            return false; // Different types are not duplicates
                        }

                        if (newQuestion.type === 'mcq' || newQuestion.type === 'sq') {
                            const newQuestionText = (newQuestion.question || '').toLowerCase().trim();
                            const existingQuestionText = (existingQuestion.question || '').toLowerCase().trim();
                            return newQuestionText === existingQuestionText;
                        } else if (newQuestion.type === 'cq') {
                            const newCQText = (newQuestion.questionText || '').toLowerCase().trim();
                            const existingCQText = (existingQuestion.questionText || '').toLowerCase().trim();

                            if (newCQText !== existingCQText) {
                                return false;
                            }

                            // Compare parts for CQ
                            if (newQuestion.parts.length !== existingQuestion.parts.length) {
                                return false;
                            }

                            return newQuestion.parts.every((newPart, index) => {
                                const existingPart = existingQuestion.parts[index];
                                return (newPart.text || '').toLowerCase().trim() === (existingPart.text || '').toLowerCase().trim();
                            });
                        }
                        return false;
                    });
                }

                async function parseMCQs() {
                    const text = mcqInput.value.trim();
                    if (!text) {
                        alert('Please enter questions to import.');
                        return;
                    }

                    const blocks = text.split(/(?=\n*\[Subject:|\n*\d+\.\s)/).filter(b => b.trim());
                    const newQuestions = [];
                    const skippedQuestions = [];
                    let currentMetadata = {
                        subject: '',
                        chapter: '',
                        lesson: '',
                        board: '',
                        isQuizzable: true,
                        tags: ['mcq']
                    };

                    for (const block of blocks) {
                        const lines = block.split('\n').map(l => l.trim()).filter(l => l);
                        if (!lines.length) continue;

                        if (lines[0].startsWith('[')) {
                            lines.forEach(line => {
                                if (line.startsWith('[Subject:')) currentMetadata.subject = line.replace('[Subject:', '').replace(']', '').trim();
                                else if (line.startsWith('[Chapter:')) currentMetadata.chapter = line.replace('[Chapter:', '').replace(']', '').trim();
                                else if (line.startsWith('[Lesson:')) currentMetadata.lesson = line.replace('[Lesson:', '').replace(']', '').trim();
                                else if (line.startsWith('[Board:')) currentMetadata.board = line.replace('[Board:', '').replace(']', '').trim();
                                else if (line.startsWith('[isQuizzable:')) currentMetadata.isQuizzable = line.replace('[isQuizzable:', '').replace(']', '').trim().toLowerCase() === 'true';
                                else if (line.startsWith('[Tags:')) {
                                    const tags = line.replace('[Tags:', '').replace(']', '').trim();
                                    currentMetadata.tags = ['mcq', ...tags.split(',').map(t => t.trim()).filter(t => t && t !== 'mcq')];
                                }
                            });
                            continue;
                        }

                        const question = {
                            ...currentMetadata,
                            id: Date.now() + Math.floor(Math.random() * 1000),
                            type: 'mcq',
                            question: '',
                            options: [],
                            correctAnswer: '',
                            explanation: '',
                            image: null,
                            synced: false
                        };

                        let questionTextLines = [];
                        let parsingOptions = false;
                        let parsingCorrectAnswer = false;
                        let parsingExplanation = false;
                        let explanationLines = [];

                        for (const line of lines) {
                            if (/^\d+\.\s/.test(line) && !parsingOptions && !parsingCorrectAnswer && !parsingExplanation) {
                                questionTextLines.push(line.replace(/^\d+\.\s/, '').trim());
                            } else if (/^\s*([a-dA-D])[\).\s]\s*(.*)/i.test(line) && !parsingCorrectAnswer && !parsingExplanation) {
                                parsingOptions = true;
                                const match = line.match(/^\s*([a-dA-D])[\).\s]\s*(.*)/i);
                                if (match) {
                                    const label = match[1].toLowerCase();
                                    const text = match[2].trim();
                                    question.options.push({ label, text: `${label}) ${text}`, image: null });
                                }
                            } else if (/^Correct:\s*([a-dA-D])/i.test(line) && !parsingExplanation) {
                                parsingOptions = false;
                                parsingCorrectAnswer = true;
                                const match = line.match(/^Correct:\s*([a-dA-D])/i);
                                if (match) question.correctAnswer = match[1].toLowerCase();
                            } else if (/^Explanation:/i.test(line)) {
                                parsingCorrectAnswer = false;
                                parsingExplanation = true;
                                explanationLines.push(line.replace(/^Explanation:/i, '').trim());
                            } else if (parsingExplanation && line.trim()) {
                                explanationLines.push(line);
                            } else if (!parsingOptions && !parsingCorrectAnswer && !parsingExplanation && line.trim()) {
                                questionTextLines.push(line);
                            }
                        }

                        question.question = questionTextLines.join('\n').trim();
                        question.explanation = explanationLines.join('\n').trim();

                        if (question.question && question.options.length >= 2 && question.correctAnswer) {
                            if (!isDuplicateQuestion(question)) {
                                newQuestions.push(question);
                            } else {
                                skippedQuestions.push(question);
                            }
                        }
                    }

                    if (newQuestions.length > 0) {
                        let successfulUploads = 0;
                        let skippedCount = skippedQuestions.length;
                        let failedUploads = 0;

                        // Process in chunks
                        for (let i = 0; i < newQuestions.length; i += CHUNK_SIZE) {
                            const chunk = newQuestions.slice(i, i + CHUNK_SIZE);
                            const chunkResults = await processChunk(chunk);

                            successfulUploads += chunkResults.successful;
                            skippedCount += chunkResults.skipped;
                            failedUploads += chunkResults.failed;
                        }

                        let message = `Processed ${newQuestions.length + skippedCount} questions:`;
                        message += `\n✅ ${successfulUploads} successfully uploaded`;
                        message += `\n🚫 ${skippedCount} duplicates skipped`;
                        message += `\n❌ ${failedUploads} failed to upload`;

                        alert(message);
                        resetFilters();
                        renderQuestionBank();
                        mcqInput.value = '';
                        document.querySelector('.tab[data-tab="bank"]').click();
                    } else if (skippedQuestions.length > 0) {
                        alert(`No new MCQ questions imported. ${skippedQuestions.length} duplicate MCQ questions were skipped.`);
                    } else {
                        alert('No valid MCQ questions found. Please check your format.');
                    }
                }
                // Parse CQs
                async function parseCQs() {
                    const text = cqInput.value.trim();
                    if (!text) {
                        alert('Please enter constructive questions to import.');
                        return;
                    }

                    const lines = text.split('\n').map(l => l.trim());
                    const newQuestions = [];
                    const skippedQuestions = [];
                    let currentQuestion = null;
                    let globalMetadata = { subject: '', chapter: '', lesson: '', board: '', isQuizzable: true, tags: ['cq'] };
                    let inAnswerSection = false;
                    let currentPartLetter = null;
                    let currentPartAnswerBuffer = [];
                    let questionTextBuffer = [];

                    for (let i = 0; i < lines.length; i++) {
                        const line = lines[i];
                        if (line.length === 0 && !inAnswerSection) continue;

                        const metadataMatch = line.match(/^(Subject|Chapter|Lesson|Board|isQuizzable|Tags):\s*(.*)$/i) || line.match(/^\[(Subject|Chapter|Lesson|Board|isQuizzable|Tags):\s*(.*?)\]$/i);
                        if (metadataMatch) {
                            const key = metadataMatch[1].toLowerCase();
                            let value = metadataMatch[2].trim();
                            if (key === 'isquizzable') value = value.toLowerCase() === 'true';
                            else if (key === 'tags') value = ['cq', ...value.split(',').map(t => t.trim()).filter(t => t && t !== 'cq')];

                            if (currentQuestion) {
                                currentQuestion[key] = value;
                            } else {
                                globalMetadata[key] = value;
                            }
                            continue;
                        }

                        if (/^Question\s+\d+/i.test(line)) {
                            if (currentQuestion) {
                                if (inAnswerSection && currentPartLetter && currentPartAnswerBuffer.length) {
                                    const part = currentQuestion.parts.find(p => p.letter === currentPartLetter);
                                    if (part) part.answer = currentPartAnswerBuffer.join('\n').trim();
                                }
                                if (currentQuestion.questionText && currentQuestion.parts.length > 0 && currentQuestion.parts.every(p => p.answer)) {
                                    if (!isDuplicateQuestion(currentQuestion)) {
                                        newQuestions.push(currentQuestion);
                                    } else {
                                        skippedQuestions.push(currentQuestion);
                                    }
                                } else {
                                    console.warn("Skipping incomplete question:", currentQuestion);
                                }
                            }
                            currentQuestion = {
                                ...globalMetadata,
                                id: Date.now() + Math.floor(Math.random() * 1000),
                                type: 'cq',
                                questionText: '',
                                image: null,
                                answerimage1: null,
                                answerimage2: null,
                                parts: [],
                                synced: false
                            };
                            inAnswerSection = false;
                            currentPartLetter = null;
                            currentPartAnswerBuffer = [];
                            questionTextBuffer = [];
                            continue;
                        }

                        if (line.toLowerCase() === 'answer:') {
                            inAnswerSection = true;
                            currentQuestion.questionText = questionTextBuffer.join('\n').trim();
                            questionTextBuffer = [];
                            continue;
                        }

                        if (!inAnswerSection) {
                            const partMatch = line.match(/^([a-d])\.\s*(.*?)\s*\((\d+)\)\s*$/i);
                            if (partMatch) {
                                if (!currentQuestion) {
                                    currentQuestion = {
                                        ...globalMetadata,
                                        id: Date.now() + Math.floor(Math.random() * 1000),
                                        type: 'cq',
                                        questionText: '',
                                        image: null,
                                        answerimage1: null,
                                        answerimage2: null,
                                        parts: [],
                                        synced: false
                                    };
                                }
                                const partLetter = partMatch[1].toLowerCase();
                                currentQuestion.parts.push({ letter: partMatch[1].toLowerCase(), text: partMatch[2].trim(), marks: parseInt(partMatch[3]), answer: '', image: null });
                                if (i + 1 < lines.length && lines[i + 1].trim() === `[There is a picture for part ${partLetter}]`) {
                                    if (partLetter === 'c') {
                                        currentQuestion.answerimage1 = '[There is a picture for part c]';
                                    } else if (partLetter === 'd') {
                                        currentQuestion.answerimage2 = '[There is a picture for part d]';
                                    }
                                    i++;
                                }
                            } else if (!line.startsWith('[There is a picture]')) {
                                questionTextBuffer.push(line);
                            }
                        } else {
                            const answerPartMatch = line.match(/^([a-d])\.\s*(.*)$/i);
                            if (answerPartMatch) {
                                if (currentPartLetter && currentPartAnswerBuffer.length) {
                                    const part = currentQuestion.parts.find(p => p.letter === currentPartLetter);
                                    if (part) part.answer = currentPartAnswerBuffer.join('\n').trim();
                                }
                                currentPartLetter = answerPartMatch[1].toLowerCase();
                                currentPartAnswerBuffer = [answerPartMatch[2]];
                            } else if (currentPartLetter && line.trim() !== "") {
                                currentPartAnswerBuffer.push(line);
                            } else if (line.trim() === "" && currentPartLetter) {
                                currentPartAnswerBuffer.push(line);
                            }
                        }
                    }

                    if (currentQuestion) {
                        if (inAnswerSection && currentPartLetter && currentPartAnswerBuffer.length) {
                            const part = currentQuestion.parts.find(p => p.letter === currentPartLetter);
                            if (part) part.answer = currentPartAnswerBuffer.join('\n').trim();
                        }
                        if (!currentQuestion.questionText && questionTextBuffer.length) {
                            currentQuestion.questionText = questionTextBuffer.join('\n').trim();
                        }
                        if (currentQuestion.questionText && currentQuestion.parts.length > 0 && currentQuestion.parts.every(p => p.answer)) {
                            if (!isDuplicateQuestion(currentQuestion)) {
                                newQuestions.push(currentQuestion);
                            } else {
                                skippedQuestions.push(currentQuestion);
                            }
                        } else {
                            console.warn("Skipping incomplete last question:", currentQuestion);
                        }
                    }

                    if (newQuestions.length > 0) {
                        let successfulUploads = 0;
                        let skippedCount = skippedQuestions.length;
                        let failedUploads = 0;

                        // Process in chunks
                        for (let i = 0; i < newQuestions.length; i += CHUNK_SIZE) {
                            const chunk = newQuestions.slice(i, i + CHUNK_SIZE);
                            const chunkResults = await processChunk(chunk);

                            successfulUploads += chunkResults.successful;
                            skippedCount += chunkResults.skipped;
                            failedUploads += chunkResults.failed;
                        }

                        let message = `Processed ${newQuestions.length + skippedCount} questions:`;
                        message += `\n✅ ${successfulUploads} successfully uploaded`;
                        message += `\n🚫 ${skippedCount} duplicates skipped`;
                        message += `\n❌ ${failedUploads} failed to upload`;

                        alert(message);
                        resetFilters();
                        renderQuestionBank();
                        cqInput.value = '';
                        document.querySelector('.tab[data-tab="bank"]').click();
                    } else if (skippedQuestions.length > 0) {
                        alert(`No new CQ questions imported. ${skippedQuestions.length} duplicate CQ questions were skipped.`);
                    } else {
                        alert('No valid CQ questions found. Please check your format.');
                    }
                }

                // New: Parse SQ Questions
                async function parseSQs() {
                    const text = sqInput.value.trim();
                    if (!text) {
                        alert('Please enter short questions to import.');
                        return;
                    }

                    const blocks = text.split(/(?=\n*\[Subject:|\n*\d+\.\s)/).filter(b => b.trim());
                    const newQuestions = [];
                    const skippedQuestions = [];
                    let currentMetadata = {
                        subject: '',
                        chapter: '',
                        lesson: '',
                        board: '',
                        isQuizzable: true,
                        tags: ['sq']
                    };

                    for (const block of blocks) {
                        const lines = block.split('\n').map(l => l.trim()).filter(l => l);
                        if (!lines.length) continue;

                        if (lines[0].startsWith('[')) {
                            lines.forEach(line => {
                                if (line.startsWith('[Subject:')) currentMetadata.subject = line.replace('[Subject:', '').replace(']', '').trim();
                                else if (line.startsWith('[Chapter:')) currentMetadata.chapter = line.replace('[Chapter:', '').replace(']', '').trim();
                                else if (line.startsWith('[Lesson:')) currentMetadata.lesson = line.replace('[Lesson:', '').replace(']', '').trim();
                                else if (line.startsWith('[Board:')) currentMetadata.board = line.replace('[Board:', '').replace(']', '').trim();
                                else if (line.startsWith('[isQuizzable:')) currentMetadata.isQuizzable = line.replace('[isQuizzable:', '').replace(']', '').trim().toLowerCase() === 'true';
                                else if (line.startsWith('[Tags:')) {
                                    const tags = line.replace('[Tags:', '').replace(']', '').trim();
                                    currentMetadata.tags = ['sq', ...tags.split(',').map(t => t.trim()).filter(t => t && t !== 'sq')];
                                }
                            });
                            continue;
                        }

                        const question = {
                            ...currentMetadata,
                            id: Date.now() + Math.floor(Math.random() * 1000),
                            type: 'sq',
                            question: '',
                            answer: '',
                            image: null,
                            synced: false
                        };

                        let questionTextBuffer = [];
                        let answerTextBuffer = [];
                        let inAnswerSection = false;

                        for (const line of lines) {
                            if (/^\d+\.\s/.test(line) && !inAnswerSection) {
                                questionTextBuffer.push(line.replace(/^\d+\.\s/, '').trim());
                            } else if (line.toLowerCase().startsWith('answer:')) {
                                inAnswerSection = true;
                                answerTextBuffer.push(line.replace(/^Answer:/i, '').trim());
                            } else if (inAnswerSection) {
                                answerTextBuffer.push(line);
                            } else if (!inAnswerSection && line.trim()) {
                                questionTextBuffer.push(line);
                            }
                        }

                        question.question = questionTextBuffer.join('\n').trim();
                        question.answer = answerTextBuffer.join('\n').trim();

                        if (question.question && question.answer) {
                            if (!isDuplicateQuestion(question)) {
                                newQuestions.push(question);
                            } else {
                                skippedQuestions.push(question);
                            }
                        } else {
                            console.warn('Skipping incomplete SQ question:', question);
                        }
                    }

                    if (newQuestions.length > 0) {
                        let successfulUploads = 0;
                        let skippedCount = skippedQuestions.length;
                        let failedUploads = 0;

                        // Process in chunks
                        for (let i = 0; i < newQuestions.length; i += CHUNK_SIZE) {
                            const chunk = newQuestions.slice(i, i + CHUNK_SIZE);
                            const chunkResults = await processChunk(chunk);

                            successfulUploads += chunkResults.successful;
                            skippedCount += chunkResults.skipped;
                            failedUploads += chunkResults.failed;
                        }

                        let message = `Processed ${newQuestions.length + skippedCount} questions:`;
                        message += `\n✅ ${successfulUploads} successfully uploaded`;
                        message += `\n🚫 ${skippedCount} duplicates skipped`;
                        message += `\n❌ ${failedUploads} failed to upload`;

                        alert(message);
                        resetFilters();
                        renderQuestionBank();
                        sqInput.value = '';
                        document.querySelector('.tab[data-tab="bank"]').click();
                    } else if (skippedQuestions.length > 0) {
                        alert(`No new SQ questions imported. ${skippedQuestions.length} duplicate SQ questions were skipped.`);
                    } else {
                        alert('No valid SQ questions found. Please check your format.');
                    }
                }

                async function processChunk(chunk) {
                    const results = {
                        successful: 0,
                        skipped: 0,
                        failed: 0
                    };

                    for (const question of chunk) {
                        try {
                            // Check if duplicate
                            if (isDuplicateQuestion(question)) {
                                results.skipped++;
                                continue;
                            }

                            // Save to Supabase
                            const success = await saveSingleQuestion(question);

                            if (success) {
                                questionBank.push(question);
                                results.successful++;
                            } else {
                                results.failed++;
                            }
                        } catch (error) {
                            console.error('Error processing question:', error);
                            results.failed++;
                        }
                    }

                    return results;
                }

                async function saveSingleQuestion(question) {
                    if (!supabaseClient) return false;

                    try {
                        const formatted = formatQuestionForSupabase(question);
                        const { error } = await supabaseClient
                            .from('questions')
                            .upsert([formatted]);

                        if (error) {
                            if (error.code === '23505') { // Unique violation error code
                                console.log('Duplicate question skipped:', question.question);
                                return false; // Treat as skipped, not failed
                            }
                            throw error;
                        }

                        question.synced = true;
                        return true;
                    } catch (error) {
                        console.error('Error saving question:', error);
                        return false;
                    }
                }

                function formatQuestionForSupabase(q) {
                    return {
                        id: q.id,
                        type: q.type,
                        subject: q.subject || null,
                        chapter: q.chapter || null,
                        lesson: q.lesson || null,
                        board: q.board || null,
                        is_quizzable: q.isQuizzable,
                        tags: q.tags || [],
                        question: q.question || null,
                        question_text: q.questionText || null,
                        options: q.options || null,
                        correct_answer: q.correctAnswer || null,
                        explanation: q.explanation || null,
                        parts: q.parts || null,
                        answer: q.answer || null,
                        image: q.image || null,
                        answerimage1: q.answerimage1 || null,
                        answerimage2: q.answerimage2 || null
                    };
                }
                
                // Render questions in the bank
                function renderQuestionBank() {
                    questionsContainer.innerHTML = '';
                    let filteredQuestions = questionBank.filter(q => {
                        const matchesSearchText = !currentFilters.searchText ||
                            (q.question?.toLowerCase().includes(currentFilters.searchText.toLowerCase())) ||
                            (q.questionText?.toLowerCase().includes(currentFilters.searchText.toLowerCase())) ||
                            (q.answer?.toLowerCase().includes(currentFilters.searchText.toLowerCase())) ||
                            (q.explanation?.toLowerCase().includes(currentFilters.searchText.toLowerCase())) ||
                            (q.parts?.some(p => (p.text?.toLowerCase().includes(currentFilters.searchText.toLowerCase())) || (p.answer?.toLowerCase().includes(currentFilters.searchText.toLowerCase())))) ||
                            q.tags.some(tag => tag.toLowerCase().includes(currentFilters.searchText.toLowerCase()));
                        const matchesSubject = !currentFilters.subject || q.subject === currentFilters.subject;
                        const matchesChapter = !currentFilters.chapter || q.chapter === currentFilters.chapter;
                        const matchesLesson = !currentFilters.lesson || q.lesson === currentFilters.lesson;
                        const matchesType = !currentFilters.type || q.type === currentFilters.type;
                        const matchesBoard = !currentFilters.board || q.board === currentFilters.board;
                        const matchesQuizzable = currentFilters.isQuizzable === '' || q.isQuizzable === (currentFilters.isQuizzable === 'true');
                        return matchesSearchText && matchesSubject && matchesChapter && matchesLesson && matchesType && matchesBoard && matchesQuizzable;
                    });

                    if (filteredQuestions.length === 0) {
                        questionsContainer.innerHTML = '<p>No questions found matching your criteria.</p>';
                        return;
                    }

                    filteredQuestions.forEach(q => {
                        const questionEl = document.createElement('div');
                        questionEl.classList.add('question');
                        let contentHtml = '';

                        if (q.type === 'mcq') {
                            contentHtml += `<p><strong>Question:</strong> ${q.question}</p>`;
                            if (q.image) contentHtml += `<img src="${q.image}" style="max-width: 200px; max-height: 200px; margin-bottom: 10px;">`;
                            contentHtml += '<ul class="options-list">';
                            q.options.forEach(option => {
                                contentHtml += `<li ${q.correctAnswer && option.label === q.correctAnswer ? 'class="correct"' : ''}>
                                    ${option.text}
                                    ${option.image ? `<img src="${option.image}" style="max-width: 100px; max-height: 100px; display: block; margin-top: 5px;">` : ''}
                                </li>`;
                            });
                            contentHtml += '</ul>';
                            contentHtml += `<p><strong>Correct Answer:</strong> ${q.correctAnswer ? q.correctAnswer.toUpperCase() : 'N/A'}</p>`;
                            if (q.explanation) contentHtml += `<p><strong>Explanation:</strong> ${q.explanation}</p>`;
                        } else if (q.type === 'cq') {
                            contentHtml += `<p><strong>Question:</strong> ${q.questionText}</p>`;
                            if (q.image) contentHtml += `<img src="${q.image}" style="max-width: 200px; max-height: 200px; margin-bottom: 10px;">`;
                            contentHtml += '<ul class="options-list">';
                            q.parts.forEach(part => {
                                let partImage = part.image;
                                // These next two lines were previously trying to use 'answerimage1'/'answerimage2' for part images.
                                // If these are meant for images embedded in the *answer* text, that's different.
                                // For images belonging *to* a part, part.image is the correct place.
                                // I'll keep your original logic here as it was, but it's atypical if these are meant as part images.
                                if (part.letter === 'c' && q.answerimage1 && q.answerimage1 !== '[There is a picture for part c]') { // Exclude placeholder string
                                    partImage = q.answerimage1;
                                } else if (part.letter === 'd' && q.answerimage2 && q.answerimage2 !== '[There is a picture for part d]') { // Exclude placeholder string
                                    partImage = q.answerimage2;
                                }

                                contentHtml += `<li>
                                    <strong>Part ${part.letter.toUpperCase()}:</strong> ${part.text} (Marks: ${part.marks})<br>
                                    <strong>Answer:</strong> ${part.answer}
                                    ${partImage ? `<img src="${partImage}" style="max-width: 100px; max-height: 100px; display: block; margin-top: 5px;">` : ''}
                                </li>`;
                            });
                            contentHtml += '</ul>';
                        } else if (q.type === 'sq') {
                            contentHtml += `<p><strong>Question:</strong> ${q.question}</p>`;
                            if (q.image) contentHtml += `<img src="${q.image}" style="max-width: 200px; max-height: 200px; margin-bottom: 10px;">`;
                            contentHtml += `<p><strong>Answer:</strong> ${q.answer}</p>`;
                        }

                        questionEl.innerHTML = `
                            <div class="metadata">
                                <span>Subject: ${q.subject || 'N/A'}</span>
                                <span>Chapter: ${q.chapter || 'N/A'}</span>
                                <span>Lesson: ${q.lesson || 'N/A'}</span>
                                <span>Board: ${q.board || 'N/A'}</span>
                                <span>Type: ${q.type ? q.type.toUpperCase() : 'N/A'}</span>
                                <span>Quizzable: ${q.isQuizzable ? 'Yes' : 'No'}</span>
                                <span>Tags: ${q.tags?.length ? q.tags.join(', ') : 'N/A'}</span>
                            </div>
                            ${contentHtml}
                            <div class="actions">
                                <button class="edit-btn" data-id="${q.id}">Edit</button>
                                <button class="danger delete-btn" data-id="${q.id}">Delete</button>
                            </div>
                        `;
                        questionsContainer.appendChild(questionEl);
                    });
                    updateStats();
                }

                // Edit question
                function editQuestion(id) {
                    const question = questionBank.find(q => q.id == id);
                    if (!question) return;

                    editQuestionId.value = question.id;
                    questionType.value = question.type || 'mcq';
                    questionType.disabled = true;
                    setFormType(question.type);
                    subjectInput.value = question.subject || '';
                    chapterInput.value = question.chapter || '';
                    lessonInput.value = question.lesson || '';
                    boardInput.value = question.board || '';
                    isQuizzableInput.checked = question.isQuizzable !== false;

                    if (question.type === 'cq') {
                        questionTextInput.value = question.questionText || '';
                    } else {
                        questionTextInput.value = question.question || '';
                    }

                    if (question.image) {
                        questionImagePreview.src = question.image;
                        questionImagePreview.style.display = 'block';
                        removeQuestionImageBtn.style.display = 'inline-block';
                    } else {
                        questionImagePreview.src = '';
                        questionImagePreview.style.display = 'none';
                        removeQuestionImageBtn.style.display = 'none';
                    }

                    optionInputs.forEach(input => {
                        const optionLetter = input.dataset.option;
                        input.value = '';
                        const marksInput = document.querySelector(`.part-marks[data-option="${optionLetter}"]`);
                        const answerTextarea = document.querySelector(`.part-answer[data-option="${optionLetter}"]`);
                        const imagePreview = document.querySelector(`.option-image-preview[data-option="${optionLetter}"]`);
                        const removeBtn = document.querySelector(`.remove-option-image-btn[data-option="${optionLetter}"]`);
                        const imageUploadInput = document.querySelector(`.option-image-upload-input[data-option="${optionLetter}"]`);

                        if (marksInput) marksInput.value = '';
                        if (answerTextarea) answerTextarea.value = '';

                        imagePreview.src = '';
                        imagePreview.style.display = 'none';
                        removeBtn.style.display = 'none';
                        imageUploadInput.value = '';
                    });
                    sqAnswerInput.value = '';
                    explanationInput.value = '';

                    if (question.type === 'mcq') {
                        question.options.forEach(option => {
                            const input = document.querySelector(`.option[data-option="${option.label}"]`);
                            if (input) {
                                input.value = option.text;
                                const imagePreview = document.querySelector(`.option-image-preview[data-option="${option.label}"]`);
                                const removeBtn = document.querySelector(`.remove-option-image-btn[data-option="${option.label}"]`);
                                if (option.image) {
                                    imagePreview.src = option.image;
                                    imagePreview.style.display = 'block';
                                    removeBtn.style.display = 'inline-block';
                                }
                            }
                        });
                        correctAnswerSelect.value = question.correctAnswer || '';
                        explanationInput.value = question.explanation || '';
                    } else if (question.type === 'cq') {
                        (question.parts || []).forEach(part => {
                            const textInput = document.querySelector(`.option[data-option="${part.letter}"]`);
                            const marksInput = document.querySelector(`.part-marks[data-option="${part.letter}"]`);
                            const answerTextarea = document.querySelector(`.part-answer[data-option="${part.letter}"]`);
                            const imagePreview = document.querySelector(`.option-image-preview[data-option="${part.letter}"]`);
                            const removeBtn = document.querySelector(`.remove-option-image-btn[data-option="${part.letter}"]`);
                            if (textInput) textInput.value = part.text || '';
                            if (marksInput) marksInput.value = part.marks || '';
                            if (answerTextarea) answerTextarea.value = part.answer || '';

                            // Original logic for c and d, consider if part.image is always better
                            if (part.letter === 'c' && question.answerimage1 && question.answerimage1 !== '[There is a picture for part c]') {
                                imagePreview.src = question.answerimage1;
                                imagePreview.style.display = 'block';
                                removeBtn.style.display = 'inline-block';
                            } else if (part.letter === 'd' && question.answerimage2 && question.answerimage2 !== '[There is a picture for part d]') {
                                imagePreview.src = question.answerimage2;
                                imagePreview.style.display = 'block';
                                removeBtn.style.display = 'inline-block';
                            } else if (part.image) { // This should ideally be the primary way to store part images
                                imagePreview.src = part.image;
                                imagePreview.style.display = 'block';
                                removeBtn.style.display = 'inline-block';
                            }
                        });
                    } else if (question.type === 'sq') {
                        sqAnswerInput.value = question.answer || '';
                    }

                    tagsInput.value = question.tags ? question.tags.join(', ') : '';
                    cancelEditBtn.style.display = 'inline-block';
                    document.querySelector('.tab[data-tab="add"]').click();
                }

                // Delete question
                async function deleteQuestion(id) {
                    if (confirm('Are you sure you want to delete this question?')) {
                        const questionToDelete = questionBank.find(q => q.id == id);
                        if (!questionToDelete) return;

                        if (!supabaseClient) {
                            alert('Supabase is not connected. Cannot delete question from the database.');
                            return;
                        }

                        // Delete associated images first
                        if (questionToDelete.image) {
                            await deleteImage(questionToDelete.image);
                        }
                        if (questionToDelete.answerimage1 && questionToDelete.answerimage1 !== '[There is a picture for part c]') {
                            await deleteImage(questionToDelete.answerimage1); // Delete part c image
                        }
                        if (questionToDelete.answerimage2 && questionToDelete.answerimage2 !== '[There is a picture for part d]') {
                            await deleteImage(questionToDelete.answerimage2); // Delete part d image
                        }
                        if (questionToDelete.type === 'mcq' && questionToDelete.options) {
                            for (const opt of questionToDelete.options) {
                                if (opt.image) await deleteImage(opt.image);
                            }
                        } else if (questionToDelete.type === 'cq' && questionToDelete.parts) {
                            for (const part of questionToDelete.parts) {
                                if (part.image) await deleteImage(part.image);
                            }
                        }

                        try {
                            const { error } = await supabaseClient
                                .from('questions')
                                .delete()
                                .eq('id', id);

                            if (error) {
                                console.error('❌ Error deleting question from Supabase:', error);
                                alert('Error deleting question from database. Please try again.');
                            } else {
                                console.log(`✅ Question ${id} deleted from Supabase.`);
                                // Only update local state if deletion from Supabase was successful
                                questionBank = questionBank.filter(q => q.id != id);
                                renderQuestionBank();
                            }
                        } catch (supabaseError) {
                            console.error('❌ Supabase delete operation failed:', supabaseError);
                            alert('Could not delete question from database. Please check your network connection.');
                        }
                    }
                }

                async function saveQuestions() {
                    if (!supabaseClient) {
                        console.error('Supabase client not available. Cannot save questions.');
                        alert('Supabase is not connected. Cannot save questions to the database.');
                        return;
                    }

                    const questionsToSync = questionBank.filter(q => !q.synced);

                    if (questionsToSync.length === 0) {
                        console.log('No questions to sync.');
                        return;
                    }

                    try {
                        const formattedQuestions = questionsToSync.map(q => {
                            const base = {
                                id: q.id,
                                type: q.type,
                                subject: q.subject || null,
                                chapter: q.chapter || null,
                                lesson: q.lesson || null,
                                board: q.board || null,
                                is_quizzable: q.isQuizzable,
                                tags: q.tags || [],
                                image: q.image || null,
                                answerimage1: q.answerimage1 || null,
                                answerimage2: q.answerimage2 || null,
                            };

                            if (q.type === 'mcq') {
                                return {
                                    ...base,
                                    question: q.question,
                                    options: q.options,
                                    correct_answer: q.correctAnswer,
                                    explanation: q.explanation || null,
                                    question_text: null,
                                    parts: null,
                                    answer: null,
                                };
                            } else if (q.type === 'cq') {
                                return {
                                    ...base,
                                    question_text: q.questionText,
                                    parts: q.parts,
                                    question: null,
                                    options: null,
                                    correct_answer: null,
                                    explanation: null,
                                    answer: null,
                                };
                            } else if (q.type === 'sq') {
                                return {
                                    ...base,
                                    question: q.question,
                                    answer: q.answer,
                                    question_text: null,
                                    options: null,
                                    correct_answer: null,
                                    explanation: null,
                                    parts: null,
                                };
                            }
                        });

                        const { data, error } = await supabaseClient
                            .from('questions')
                            .upsert(formattedQuestions, { onConflict: 'id' });

                        if (error) {
                            console.error('Error saving questions to Supabase:', error);
                            alert('Failed to save questions to Supabase. Please try again.');
                        } else {
                            console.log('Questions saved successfully:', data);
                            // Mark the questions as synced in the local questionBank
                            questionsToSync.forEach(q => (q.synced = true));
                        }
                    } catch (error) {
                        console.error('Error during saveQuestions:', error);
                        alert('An error occurred while saving questions. Please check the console for details.');
                    }
                }

                
                async function saveQuestion() {
                    if (!supabaseClient) {
                        alert('Supabase is not connected. Cannot save question.');
                        return;
                    }

                    const type = questionType.value;
                    if (!type || !questionTextInput.value.trim()) {
                        alert('Please enter a question and select a type.');
                        return;
                    }

                    const existingQuestion = editQuestionId.value ? questionBank.find(q => q.id == editQuestionId.value) : null;

                    const question = {
                        id: editQuestionId.value ? parseInt(editQuestionId.value) : Date.now() + Math.floor(Math.random() * 1000),
                        type,
                        subject: subjectInput.value.trim(),
                        chapter: chapterInput.value.trim(),
                        lesson: lessonInput.value.trim(),
                        board: boardInput.value.trim(),
                        isQuizzable: isQuizzableInput.checked,
                        tags: tagsInput.value.split(',').map(t => t.trim()).filter(t => t),
                        image: null,
                        answerimage1: null, // For CQ specific answer images (part c, d etc)
                        answerimage2: null, // For CQ specific answer images (part c, d etc)
                        explanation: null,
                        synced: false // Mark as unsynced for new or edited questions
                    };

                    if (!question.tags.includes(type)) question.tags.push(type);

                    // Handle question image upload/deletion
                    if (questionImageUpload.files.length > 0) {
                        const oldImageUrl = existingQuestion?.image;
                        if (oldImageUrl) await deleteImage(oldImageUrl);
                        questionImagePreview.src = 'Uploading...';
                        const imageUrl = await uploadImage(questionImageUpload.files[0], 'questions');
                        if (imageUrl) {
                            question.image = imageUrl;
                        } else {
                            alert('Failed to upload question image. Please try again.');
                            questionImagePreview.src = '';
                            return;
                        }
                    } else if (questionImagePreview.src && questionImagePreview.style.display === 'block') {
                        question.image = questionImagePreview.src;
                    } else {
                        const oldImageUrl = existingQuestion?.image;
                        if (oldImageUrl) await deleteImage(oldImageUrl);
                        question.image = null;
                    }

                    if (type === 'mcq') {
                        question.question = questionTextInput.value.trim();
                        question.explanation = explanationInput.value.trim();
                        const options = [];
                        for (const input of optionInputs) {
                            const optionLetter = input.dataset.option;
                            const text = input.value.trim();
                            const imageUploadInput = document.querySelector(`.option-image-upload-input[data-option="${optionLetter}"]`);
                            const imagePreview = document.querySelector(`.option-image-preview[data-option="${optionLetter}"]`);

                            let optionImage = null;
                            const existingOption = existingQuestion?.options?.find(opt => opt.label === optionLetter);

                            if (imageUploadInput.files.length > 0) {
                                if (existingOption?.image) await deleteImage(existingOption.image);
                                imagePreview.src = 'Uploading...';
                                optionImage = await uploadImage(imageUploadInput.files[0], `options/${question.id}`);
                                if (!optionImage) {
                                    alert(`Failed to upload image for option ${optionLetter}. Please try again.`);
                                    return;
                                }
                            } else if (imagePreview.src && imagePreview.style.display === 'block') {
                                optionImage = imagePreview.src;
                            } else {
                                if (existingOption?.image) await deleteImage(existingOption.image);
                            }

                            if (text || optionImage) {
                                options.push({
                                    label: optionLetter,
                                    text: text,
                                    image: optionImage
                                });
                            }
                        }
                        if (options.length < 2 || !correctAnswerSelect.value) {
                            alert('Please provide at least 2 options and select a correct answer.');
                            return;
                        }
                        question.options = options;
                        question.correctAnswer = correctAnswerSelect.value;
                        delete question.questionText;
                        delete question.parts;
                        delete question.answer;
                    } else if (type === 'cq') {
                        question.questionText = questionTextInput.value.trim();
                        const parts = [];
                        for (const letter of ['a', 'b', 'c', 'd']) {
                            const textInput = document.querySelector(`.option[data-option="${letter}"]`);
                            const marksInput = document.querySelector(`.part-marks[data-option="${letter}"]`);
                            const answerTextarea = document.querySelector(`.part-answer[data-option="${letter}"]`);
                            const imageUploadInput = document.querySelector(`.option-image-upload-input[data-option="${letter}"]`);
                            const imagePreview = document.querySelector(`.option-image-preview[data-option="${letter}"]`);

                            const text = textInput.value.trim();
                            const marks = marksInput.value.trim();
                            const answer = answerTextarea.value.trim();

                            let partImage = null;
                            const existingPart = existingQuestion?.parts?.find(p => p.letter === letter);

                            if (imageUploadInput.files.length > 0) {
                                if (existingPart?.image) await deleteImage(existingPart.image);
                                imagePreview.src = 'Uploading...';
                                partImage = await uploadImage(imageUploadInput.files[0], `parts/${question.id}`);
                                if (!partImage) {
                                    alert(`Failed to upload image for part ${letter}. Please try again.`);
                                    return;
                                }
                            } else if (imagePreview.src && imagePreview.style.display === 'block') {
                                partImage = imagePreview.src;
                            } else {
                                if (existingPart?.image) await deleteImage(existingPart.image);
                            }

                            // Handling specific part images as answerimage1/answerimage2 (your original logic)
                            if (letter === 'c') {
                                if (partImage) {
                                    if (existingQuestion?.answerimage1 && existingQuestion.answerimage1 !== partImage && existingQuestion.answerimage1 !== '[There is a picture for part c]') {
                                        await deleteImage(existingQuestion.answerimage1);
                                    }
                                    question.answerimage1 = partImage;
                                } else if (existingQuestion?.answerimage1 && existingQuestion.answerimage1 !== '[There is a picture for part c]') {
                                    await deleteImage(existingQuestion.answerimage1);
                                    question.answerimage1 = null;
                                }
                            }

                            if (letter === 'd') {
                                if (partImage) {
                                    if (existingQuestion?.answerimage2 && existingQuestion.answerimage2 !== partImage && existingQuestion.answerimage2 !== '[There is a picture for part d]') {
                                        await deleteImage(existingQuestion.answerimage2);
                                    }
                                    question.answerimage2 = partImage;
                                } else if (existingQuestion?.answerimage2 && existingQuestion.answerimage2 !== '[There is a picture for part d]') {
                                    await deleteImage(existingQuestion.answerimage2);
                                    question.answerimage2 = null;
                                }
                            }

                            if (text && marks && answer) {
                                parts.push({ letter, text, marks: parseInt(marks), answer, image: partImage });
                            }
                        }
                        if (parts.length === 0) {
                            alert('Please provide at least one part with question, marks, and answer.');
                            return;
                        }
                        question.parts = parts;
                        delete question.question;
                        delete question.options;
                        delete question.correctAnswer;
                        delete question.answer;
                        delete question.explanation;
                    } else if (type === 'sq') {
                        question.question = questionTextInput.value.trim();
                        question.answer = sqAnswerInput.value.trim();
                        if (!question.question || !question.answer) {
                            alert('Please provide both a question and an answer for Short Questions.');
                            return;
                        }
                        delete question.questionText;
                        delete question.options;
                        delete question.correctAnswer;
                        delete question.parts;
                        delete question.explanation;
                    }

                    // Check for duplicate only if it's a new question, not an edit
                    if (!editQuestionId.value) {
                        if (isDuplicateQuestion(question)) {
                            alert('This question already exists in the bank. Duplicate questions cannot be added.');
                            return;
                        }
                    }

                    const index = questionBank.findIndex(q => q.id == editQuestionId.value);
                    if (index !== -1) {
                        questionBank[index] = question;
                        console.log('Updated existing question:', question.id);
                    } else {
                        questionBank.push(question);
                        console.log('Added new question:', question.id);
                    }

                    try {
                        await saveQuestions();
                        alert('Question saved successfully!');
                    } catch (error) {
                        console.error('Error saving question:', error);
                        alert('Error saving question. Please try again.');
                        return;
                    }
                    resetQuestionForm();
                    renderQuestionBank();
                    document.querySelector('.tab[data-tab="bank"]').click();
                }
                function resetQuestionForm() {
                    editQuestionId.value = '';
                    questionType.value = 'mcq';
                    questionType.disabled = false;
                    setFormType('mcq');
                    subjectInput.value = '';
                    chapterInput.value = '';
                    lessonInput.value = '';
                    boardInput.value = '';
                    isQuizzableInput.checked = true;
                    questionTextInput.value = '';
                    questionImagePreview.src = '';
                    questionImagePreview.style.display = 'none';
                    removeQuestionImageBtn.style.display = 'none';
                    questionImageUpload.value = '';
                    optionInputs.forEach(input => {
                        const optionLetter = input.dataset.option;
                        input.value = '';
                        const imagePreview = document.querySelector(`.option-image-preview[data-option="${optionLetter}"]`);
                        const removeBtn = document.querySelector(`.remove-option-image-btn[data-option="${optionLetter}"]`);
                        const marksInput = document.querySelector(`.part-marks[data-option="${optionLetter}"]`);
                        const answerTextarea = document.querySelector(`.part-answer[data-option="${optionLetter}"]`);
                        const optionImageInput = document.querySelector(`.option-image-upload-input[data-option="${optionLetter}"]`);

                        imagePreview.src = '';
                        imagePreview.style.display = 'none';
                        removeBtn.style.display = 'none';
                        if (marksInput) marksInput.value = '';
                        if (answerTextarea) answerTextarea.value = '';
                        if (optionImageInput) optionImageInput.value = '';
                    });
                    correctAnswerSelect.value = '';
                    sqAnswerInput.value = '';
                    explanationInput.value = '';
                    tagsInput.value = '';
                    cancelEditBtn.style.display = 'none';
                }

                // Apply filters
                function applyFilters() {
                    currentFilters = {
                        searchText: searchText.value.trim(),
                        subject: filterSubject.value,
                        chapter: filterChapter.value,
                        lesson: filterLesson.value,
                        type: filterType.value,
                        board: filterBoard.value,
                        isQuizzable: filterQuizzable.value
                    };
                    renderQuestionBank();
                }

                // Reset filters
                function resetFilters() {
                    searchText.value = '';
                    filterSubject.value = '';
                    filterChapter.value = '';
                    filterLesson.value = '';
                    filterType.value = '';
                    filterBoard.value = '';
                    filterQuizzable.value = '';
                    currentFilters = {};
                    updateFilters();
                    renderQuestionBank();
                }

                // Update general statistics
                function updateStats() {
                    totalQuestionsEl.textContent = questionBank.length;
                    const subjects = new Set(questionBank.map(q => q.subject).filter(s => s));
                    subjectsCountEl.textContent = subjects.size;
                    const chapters = new Set(questionBank.map(q => q.chapter).filter(c => c));
                    chaptersCountEl.textContent = chapters.size;
                    updateDetailedStats(); // Call detailed stats
                }

                // NEW: Update Detailed Statistics
                function updateDetailedStats() {
                    const stats = {};

                    questionBank.forEach(q => {
                        const subject = q.subject || 'Uncategorized Subject';
                        const chapter = q.chapter || 'Uncategorized Chapter';
                        const type = q.type || 'unknown'; // 'mcq', 'cq', 'sq'

                        // Initialize subject if not exists
                        if (!stats[subject]) {
                            stats[subject] = { mcq: {}, cq: {}, sq: {}, total: 0 };
                        }

                        // Increment total for subject
                        stats[subject].total++;

                        // Handle question type
                        if (type === 'mcq') {
                            if (!stats[subject].mcq[chapter]) {
                                stats[subject].mcq[chapter] = 0;
                            }
                            stats[subject].mcq[chapter]++;
                        } else if (type === 'cq') {
                            if (!stats[subject].cq[chapter]) {
                                stats[subject].cq[chapter] = 0;
                            }
                            stats[subject].cq[chapter]++;
                        } else if (type === 'sq') { // New SQ stat
                            if (!stats[subject].sq[chapter]) {
                                stats[subject].sq[chapter] = 0;
                            }
                            stats[subject].sq[chapter]++;
                        }
                    });

                    let detailedHtml = '<ul>';
                    const sortedSubjects = Object.keys(stats).sort();

                    sortedSubjects.forEach(subject => {
                        detailedHtml += `<li><strong>${subject}:</strong> Total Questions: ${stats[subject].total}`;

                        const sortedChaptersMCQ = Object.keys(stats[subject].mcq).sort();
                        if (sortedChaptersMCQ.length > 0) {
                            detailedHtml += ` (MCQ: `;
                            sortedChaptersMCQ.forEach((chapter, index) => {
                                detailedHtml += `${chapter}: ${stats[subject].mcq[chapter]}`;
                                if (index < sortedChaptersMCQ.length - 1) detailedHtml += ', ';
                            });
                            detailedHtml += `)`;
                        }

                        const sortedChaptersCQ = Object.keys(stats[subject].cq).sort();
                        if (sortedChaptersCQ.length > 0) {
                            detailedHtml += ` (CQ: `;
                            sortedChaptersCQ.forEach((chapter, index) => {
                                detailedHtml += `${chapter}: ${stats[subject].cq[chapter]}`;
                                if (index < sortedChaptersCQ.length - 1) detailedHtml += ', ';
                            });
                            detailedHtml += `)`;
                        }

                        const sortedChaptersSQ = Object.keys(stats[subject].sq).sort(); // New SQ stat display
                        if (sortedChaptersSQ.length > 0) {
                            detailedHtml += ` (SQ: `;
                            sortedChaptersSQ.forEach((chapter, index) => {
                                detailedHtml += `${chapter}: ${stats[subject].sq[chapter]}`;
                                if (index < sortedChaptersSQ.length - 1) detailedHtml += ', ';
                            });
                            detailedHtml += `)`;
                        }

                        detailedHtml += `</li>`;
                    });

                    detailedHtml += '</ul>';
                    detailedStatsContent.innerHTML = detailedHtml;
                }


                // Update filter dropdowns
                function updateFilters() {
                    const subjects = ['', ...new Set(questionBank.map(q => q.subject).filter(s => s))].sort();
                    filterSubject.innerHTML = subjects.map(s => `<option value="${s}" ${currentFilters.subject === s ? 'selected' : ''}>${s || 'All Subjects'}</option>`).join('');

                    let chaptersFilteredBySubject = currentFilters.subject ? questionBank.filter(q => q.subject === currentFilters.subject) : questionBank;
                    const chapters = ['', ...new Set(chaptersFilteredBySubject.map(q => q.chapter).filter(c => c))].sort();
                    filterChapter.innerHTML = chapters.map(c => `<option value="${c}" ${currentFilters.chapter === c ? 'selected' : ''}>${c || 'All Chapters'}</option>`).join('');

                    let lessonsFiltered = questionBank;
                    if (currentFilters.subject) lessonsFiltered = lessonsFiltered.filter(q => q.subject === currentFilters.subject);
                    if (currentFilters.chapter) lessonsFiltered = lessonsFiltered.filter(q => q.chapter === currentFilters.chapter);
                    const lessons = ['', ...new Set(lessonsFiltered.map(q => q.lesson).filter(l => l))].sort();
                    filterLesson.innerHTML = lessons.map(l => `<option value="${l}" ${currentFilters.lesson === l ? 'selected' : ''}>${l || 'All Lessons'}</option>`).join('');

                    const boards = ['', ...new Set(questionBank.map(q => q.board).filter(b => b))].sort();
                    filterBoard.innerHTML = boards.map(b => `<option value="${b}" ${currentFilters.board === b ? 'selected' : ''}>${b || 'All Boards'}</option>`).join('');
                    filterQuizzable.value = currentFilters.isQuizzable || '';
                }

                // Export questions
                function exportQuestions() {
                    const dataStr = JSON.stringify(questionBank, null, 2);
                    const blob = new Blob([dataStr], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'questions-export.json';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }

                // Import questions
                function importQuestions() {
                    if (!supabaseClient) {
                        alert('Supabase is not connected. Cannot import questions to the database.');
                        return;
                    }
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = '.json';
                    input.onchange = async e => {
                        const file = e.target.files[0];
                        if (!file) return;
                        const reader = new FileReader();
                        reader.onload = async event => {
                            try {
                                const importedQuestions = JSON.parse(event.target.result);
                                if (Array.isArray(importedQuestions) && importedQuestions.length) {
                                    if (confirm(`Import ${importedQuestions.length} questions? This will add them to your existing bank and skip duplicates.`)) {
                                        let newAddedCount = 0; // Changed to let
                                        let skippedCount = 0; // Changed to let

                                        // Ensure imported questions have unique IDs to prevent conflicts during upsert
                                        const processedImportedQuestions = importedQuestions.map(q => ({
                                            ...q,
                                            id: q.id || (Date.now() + Math.floor(Math.random() * 1000)), // Assign new ID if missing
                                            synced: false // Imported questions are initially unsynced
                                        }));

                                        for (const newQ of processedImportedQuestions) {
                                            if (!isDuplicateQuestion(newQ)) {
                                                const existingIndex = questionBank.findIndex(q => q.id === newQ.id);
                                                if (existingIndex !== -1) {
                                                    // Update existing question
                                                    questionBank[existingIndex] = newQ;
                                                } else {
                                                    // Add new question
                                                    questionBank.push(newQ);
                                                    newAddedCount++;
                                                }
                                            } else {
                                                skippedCount++;
                                            }
                                        }

                                        await saveQuestions(); // Attempt to save all changes to Supabase
                                        // After saving, re-load from Supabase to ensure consistency
                                        questionBank = await loadQuestions();
                                        resetFilters();
                                        renderQuestionBank();
                                        alert(`Questions imported successfully! Added ${newAddedCount} new questions. Skipped ${skippedCount} duplicate questions.`);
                                    }
                                } else {
                                    alert('No valid questions found in the file.');
                                }
                            } catch (error) {
                                console.error('Error importing questions:', error);
                                alert('Error importing questions. Check the file format or Supabase connection.');
                            }
                        };
                        reader.readAsText(file);
                    };
                    input.click();
                }

                // Image upload handlers
                questionImageUpload.addEventListener('click', function() { this.value = ''; });
                questionImageUpload.addEventListener('change', function(e) {
                    const file = e.target.files[0];
                    if (file) {
                        if (!file.type.match('image.*')) {
                            alert('Please select an image file.');
                            this.value = '';
                            return;
                        }
                        if (file.size > 2 * 1024 * 1024) { // 2MB limit
                            alert('Image size should be less than 2MB.');
                            this.value = '';
                            return;
                        }
                        const reader = new FileReader();
                        reader.onload = event => {
                            questionImagePreview.src = event.target.result; // Temporarily display
                            questionImagePreview.style.display = 'block';
                            removeQuestionImageBtn.style.display = 'inline-block';
                        };
                        reader.readAsDataURL(file);
                    }
                });

                removeQuestionImageBtn.addEventListener('click', async function() {
                    const currentQuestionId = editQuestionId.value;
                    const existingQuestion = questionBank.find(q => q.id == currentQuestionId);
                    if (existingQuestion && existingQuestion.image) {
                        await deleteImage(existingQuestion.image);
                        existingQuestion.image = null; // Clear image URL in the object
                        existingQuestion.synced = false; // Mark for re-sync
                        await saveQuestions(); // Save the change immediately
                    }
                    questionImagePreview.src = '';
                    questionImagePreview.style.display = 'none';
                    this.style.display = 'none';
                    questionImageUpload.value = '';
                });

                optionImageUploadInputs.forEach(input => {
                    input.addEventListener('click', function() { this.value = ''; });
                    input.addEventListener('change', function(e) {
                        const file = e.target.files[0];
                        const optionLetter = this.dataset.option;
                        const preview = document.querySelector(`.option-image-preview[data-option="${optionLetter}"]`);
                        const removeBtn = document.querySelector(`.remove-option-image-btn[data-option="${optionLetter}"]`);
                        if (file) {
                            if (!file.type.match('image.*')) {
                                alert('Please select an image file.');
                                this.value = '';
                                return;
                            }
                            if (file.size > 2 * 1024 * 1024) { // 2MB limit
                                alert('Image size should be less than 2MB.');
                                this.value = '';
                                return;
                            }
                            const reader = new FileReader();
                            reader.onload = event => {
                                preview.src = event.target.result; // Temporarily display
                                preview.style.display = 'block';
                                removeBtn.style.display = 'inline-block';
                            };
                            reader.readAsDataURL(file);
                        }
                    });
                });

                removeOptionImageBtns.forEach(btn => {
                    btn.addEventListener('click', async function() {
                        const optionLetter = this.dataset.option;
                        const preview = document.querySelector(`.option-image-preview[data-option="${optionLetter}"]`);
                        const input = document.querySelector(`.option-image-upload-input[data-option="${optionLetter}"]`);

                        const currentQuestionId = editQuestionId.value;
                        const existingQuestion = questionBank.find(q => q.id == currentQuestionId);

                        if (existingQuestion) {
                            if (existingQuestion.type === 'mcq') {
                                const existingOption = existingQuestion.options?.find(opt => opt.label === optionLetter);
                                if (existingOption && existingOption.image) {
                                    await deleteImage(existingOption.image);
                                    existingOption.image = null;
                                    existingQuestion.synced = false; // Mark for re-sync
                                    await saveQuestions(); // Save the change immediately
                                }
                            } else if (existingQuestion.type === 'cq') {
                                const existingPart = existingQuestion.parts?.find(p => p.letter === optionLetter);
                                if (existingPart && existingPart.image) {
                                    await deleteImage(existingPart.image);
                                    existingPart.image = null;
                                    existingQuestion.synced = false; // Mark for re-sync
                                    await saveQuestions(); // Save the change immediately
                                }
                                // Also handle specific answerimage1/answerimage2 for CQ parts c and d
                                if (optionLetter === 'c' && existingQuestion.answerimage1 && existingQuestion.answerimage1 !== '[There is a picture for part c]') {
                                    await deleteImage(existingQuestion.answerimage1);
                                    existingQuestion.answerimage1 = null;
                                    existingQuestion.synced = false;
                                    await saveQuestions();
                                }
                                if (optionLetter === 'd' && existingQuestion.answerimage2 && existingQuestion.answerimage2 !== '[There is a picture for part d]') {
                                    await deleteImage(existingQuestion.answerimage2);
                                    existingQuestion.answerimage2 = null;
                                    existingQuestion.synced = false;
                                    await saveQuestions();
                                }
                            }
                        }

                        preview.src = '';
                        preview.style.display = 'none';
                        this.style.display = 'none';
                        input.value = '';
                    });
                });

                // Attach event listeners
                function attachEventListeners() {
                    console.log("🔄 Attaching event listeners...");

                    if (parseBtn) {
                        parseBtn.addEventListener('click', parseMCQs);
                        console.log("✅ Parse MCQ button listener attached");
                    } else {
                        console.error("❌ Parse MCQ button not found");
                    }

                    if (clearImportBtn) {
                        clearImportBtn.addEventListener('click', () => mcqInput.value = '');
                        console.log("✅ Clear import button listener attached");
                    } else {
                        console.error("❌ Clear import button not found");
                    }

                    if (parseCqBtn) {
                        parseCqBtn.addEventListener('click', parseCQs);
                        console.log("✅ Parse CQ button listener attached");
                    } else {
                        console.error("❌ Parse CQ button not found");
                    }

                    if (clearCqBtn) {
                        clearCqBtn.addEventListener('click', () => cqInput.value = '');
                        console.log("✅ Clear CQ button listener attached");
                    } else {
                        console.error("❌ Clear CQ button not found");
                    }

                    if (parseSqBtn) { // New SQ parse listener
                        parseSqBtn.addEventListener('click', parseSQs);
                        console.log("✅ Parse SQ button listener attached");
                    } else {
                        console.error("❌ Parse SQ button not found");
                    }

                    if (clearSqBtn) { // New SQ clear listener
                        clearSqBtn.addEventListener('click', () => sqInput.value = '');
                        console.log("✅ Clear SQ button listener attached");
                    } else {
                        console.error("❌ Clear SQ button not found");
                    }

                    if (saveQuestionBtn) {
                        saveQuestionBtn.addEventListener('click', saveQuestion);
                        console.log("✅ Save question button listener attached");
                    } else {
                        console.error("❌ Save question button not found");
                    }

                    if (cancelEditBtn) {
                        cancelEditBtn.addEventListener('click', resetQuestionForm);
                        console.log("✅ Cancel edit button listener attached");
                    } else {
                        console.error("❌ Cancel edit button not found");
                    }

                    if (applyFiltersBtn) applyFiltersBtn.addEventListener('click', applyFilters);
                    if (resetFiltersBtn) resetFiltersBtn.addEventListener('click', resetFilters);
                    if (exportBtn) exportBtn.addEventListener('click', exportQuestions);
                    if (importBtn) importBtn.addEventListener('click', importQuestions);

                    if (filterSubject) filterSubject.addEventListener('change', () => {
                        currentFilters.subject = filterSubject.value;
                        currentFilters.chapter = '';
                        currentFilters.lesson = '';
                        updateFilters();
                        renderQuestionBank();
                    });

                    if (filterChapter) filterChapter.addEventListener('change', () => {
                        currentFilters.chapter = filterChapter.value;
                        currentFilters.lesson = '';
                        updateFilters();
                        renderQuestionBank();
                    });

                    if (filterLesson) filterLesson.addEventListener('change', () => {
                        currentFilters.lesson = filterLesson.value;
                        renderQuestionBank();
                    });

                    if (filterType) filterType.addEventListener('change', () => {
                        currentFilters.type = filterType.value;
                        renderQuestionBank();
                    });

                    if (filterBoard) filterBoard.addEventListener('change', () => {
                            currentFilters.board = filterBoard.value;
                            renderQuestionBank();
                        });

                    if (filterQuizzable) filterQuizzable.addEventListener('change', () => {
                        currentFilters.isQuizzable = filterQuizzable.value;
                        renderQuestionBank();
                    });

                    if (questionType) questionType.addEventListener('change', () => setFormType(questionType.value));

                    if (questionsContainer) questionsContainer.addEventListener('click', e => {
                        if (e.target.classList.contains('edit-btn')) {
                            e.preventDefault();
                            editQuestion(e.target.dataset.id);
                        } else if (e.target.classList.contains('delete-btn')) {
                            e.preventDefault();
                            deleteQuestion(e.target.dataset.id);
                        }
                    });

                    console.log("✅ All event listeners attached successfully");
                }

                // Initialize the app
                async function init() {
                    try {
                        console.log("🔄 Starting app initialization...");
                        const supabaseConnected = await initSupabase(); // Initialize Supabase first and await its connection status

                        if (supabaseConnected) {
                            console.log("🔄 Loading questions from Supabase...");
                            questionBank = await loadQuestions(); // Load questions exclusively from Supabase
                        } else {
                            // If Supabase connection fails, stop initialization and alert user
                            console.error("Application cannot proceed without Supabase connection.");
                            return;
                        }

                        console.log("🔄 Rendering question bank...");
                        renderQuestionBank();
                        console.log("🔄 Updating stats...");
                        updateStats(); // This now calls updateDetailedStats
                        console.log("🔄 Updating filters...");
                        updateFilters();
                        console.log("🔄 Attaching event listeners...");
                        attachEventListeners();
                        console.log("🔄 Setting form type...");
                        setFormType('mcq'); // Default to MCQ form
                        console.log("✅ App initialized successfully!");
                    } catch (error) {
                        console.error("❌ Error initializing app:", error);
                        alert("Error initializing the application. Please check the console for details.");
                    }
                }

                init().catch(console.error);
            }
        });
    </script>
</body>
</html>

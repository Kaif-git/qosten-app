<!DOCTYPE html>
<html lang="en">
<head>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Question Bank with Image Uploads</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 15px;
            line-height: 1.5;
            color: #333;
            font-size: 16px;
        }
        .header {
            display: flex;
            flex-direction: column;
            margin-bottom: 20px;
        }
        .panel {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        textarea, input, select {
            width: 100%;
            padding: 10px;
            margin-bottom: 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: inherit;
            font-size: 16px;
            box-sizing: border-box;
        }
        textarea {
            min-height: 120px;
            resize: vertical;
        }
        button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin-right: 8px;
            margin-bottom: 8px;
            transition: background-color 0.3s;
            width: auto
        }
        button:hover {
            background-color: #45a049;
        }
        button.danger {
            background-color: #f44336;
        }
        button.secondary {
            background-color: #2196F3;
        }
        .question {
            border: 1px solid #ddd;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 8px;
            background-color: white;
            position: relative;
        }
        .correct {
            font-weight: bold;
            color: #2e7d32;
        }
        .metadata {
            color: #666;
            font-size: 0.9em;
            margin-bottom: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        .metadata span {
            background: #e3f2fd;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.8em;
        }
        .actions {
            display: flex;
            gap: 8px;
            margin-top: 15px;
            justify-content: flex-end;
        }
        .actions button {
            padding: 8px 12px;
            font-size: 14px;
        }
        .options-list {
            list-style-type: none;
            padding-left: 0;
            margin-top: 10px;
        }
        .options-list li {
            padding: 5px 0;
        }
        .search-filters {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 15px;
        }
        .tab-container {
            display: flex;
            margin-bottom: 15px;
            overflow-x: auto;
            white-space: nowrap;
            padding-bottom: 5px;
        }
        .tab {
            padding: 10px 15px;
            cursor: pointer;
            background: #e0e0e0;
            border-radius: 5px;
            margin-right: 5px;
            display: inline-block;
            font-size: 14px;
        }
        .tab.active {
            background: #4CAF50;
            color: white;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .stats {
            display: flex;
            justify-content: space-between;
            background: #e3f2fd;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 10px;
        }
        .stat-item {
            text-align: center;
            min-width: 80px;
        }
        .stat-value {
            font-size: 20px;
            font-weight: bold;
            color: #0d47a1;
        }
        .image-upload-container {
            margin: 15px 0;
        }
        .image-preview {
            max-width: 100%;
            max-height: 200px;
            margin-top: 10px;
            display: none;
        }
        .option-image-upload {
            display: flex;
            flex-direction: column;
            margin-top: 5px;
        }
        .option-image-preview {
            max-width: 100%;
            max-height: 150px;
            margin-top: 5px;
            display: none;
        }
        /* New classes for type-specific forms */
        .cq-only, .sq-only {
            display: none; /* Hidden by default */
        }
        .mcq-only {
            display: block; /* Shown by default */
        }

        /* When editing/adding a CQ, show CQ-only fields and hide others */
        .editing-cq .cq-only {
            display: block;
        }
        .editing-cq .mcq-only,
        .editing-cq .sq-only {
            display: none;
        }

        /* When editing/adding an MCQ, show MCQ-only fields and hide others */
        .editing-mcq .mcq-only {
            display: block;
        }
        .editing-mcq .cq-only,
        .editing-mcq .sq-only {
            display: none;
        }

        /* When editing/adding an SQ, show SQ-only fields and hide others */
        .editing-sq .sq-only {
            display: block;
        }
        .editing-sq .mcq-only,
        .editing-sq .cq-only {
            display: none;
        }

        .option-fields div {
            margin-bottom: 15px;
        }
        .part-marks {
            width: 80px;
            margin-top: 5px;
        }
        .part-answer {
            min-height: 80px;
            margin-top: 5px;
        }
        @media (min-width: 768px) {
            body {
                max-width: 1200px;
                margin: 0 auto;
                padding: 20px;
            }
            .header {
                flex-direction: row;
                justify-content: space-between;
                align-items: center;
            }
            .search-filters {
                flex-direction: row;
                flex-wrap: wrap;
            }
            .search-filters > div {
                flex: 1;
                min-width: 150px;
            }
            .tab-container {
                white-space: normal;
                flex-wrap: wrap;
            }
        }
        .format-example {
            margin: 15px 0;
            overflow: hidden;
        }
        .format-example pre {
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-x: auto;
            background: #f5f5f5;
            padding: 15px;
            border-radius: 4px;
            max-height: 300px;
            font-family: monospace;
            line-height: 1.4;
            border: 1px solid #ddd;
        }
        #cqInput, #sqInput {
            width: 100%;
            min-height: 200px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: inherit;
            resize: vertical;
            margin-top: 10px;
        }
        .button-group {
            margin: 15px 0;
            display: flex;
            gap: 10px;
        }
        @media (max-width: 768px) {
            .format-example pre {
                font-size: 14px;
                padding: 10px;
            }
            #cqInput, #sqInput {
                min-height: 150px;
            }
        }
        .metadata-fields {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }
        .metadata-fields div {
            display: flex;
            flex-direction: column;
        }
        .metadata-fields label {
            margin-bottom: 5px;
            font-weight: 500;
            color: #555;
        }
        .metadata-fields input[type="text"] {
            padding: 8px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        .metadata-fields input[type="checkbox"] {
            width: auto;
            margin-top: 5px;
        }
        .detailed-stats {
            margin-top: 20px;
            padding: 15px;
            background: #f0f4f7;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .detailed-stats h3 {
            margin-top: 0;
            color: #0d47a1;
        }
        .detailed-stats ul {
            list-style: none;
            padding: 0;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        .detailed-stats li {
            background: #e3f2fd;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.9em;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .detailed-stats li strong {
            color: #333;
        }
        /* New class for SQ specific answer textarea */
        .sq-answer {
            min-height: 100px;
            margin-top: 5px;
        }
        /* Password Overlay Styles */
        .password-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .password-prompt {
            background-color: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            text-align: center;
        }
        .password-prompt input {
            margin: 15px 0;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 200px;
        }
        .password-prompt button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .mcq-example {
            white-space: pre-wrap; /* Ensures text wraps to the next line */
            word-wrap: break-word; /* Breaks long words to prevent overflow */
            max-width: 100%; /* Keeps content within the parent container */
            overflow-x: auto; /* Adds horizontal scrollbar if needed */
            background-color: #f8f8f8; /* Light background for readability */
            padding: 15px; /* Matches existing panel padding */
            border-radius: 5px; /* Matches existing panel styling */
            font-size: 14px; /* Matches input field font size */
            line-height: 1.5; /* Improves readability */
        }

    </style>
</head>
    <body>
        <div id="password-overlay" class="password-overlay">
            <div class="password-prompt">
                <h2>Enter Password</h2>
                <input type="password" id="password-input" placeholder="Password">
                <button id="password-submit">Submit</button>
            </div>
        </div>

        <div class="header">
            <h1>Advanced Question Bank with Images</h1>
            <div>
                <button id="exportBtn" class="secondary">Export All</button>
                <button id="importBtn" class="secondary">Import JSON</button>
            </div>
        </div>

        <div class="tab-container">
            <div class="tab active" data-tab="import">Import Questions</div>
            <div class="tab" data-tab="bank">Question Bank</div>
            <div class="tab" data-tab="add">Add New Question</div>
            <div class="tab" data-tab="cq">Import CQ</div>
            <div class="tab" data-tab="sq">Import SQ</div>
            <div class="tab" data-tab="import-bn">Import Bangla Questions</div>
            <div class="tab" data-tab="cq-bn">Import Bangla CQ</div>
            <div class="tab" data-tab="sq-bn">Import Bangla SQ</div>
        </div>

        <div class="tab-content active" id="import-tab">
            <div class="panel">
                <h2>Bulk Import Questions</h2>
                <p>Format your questions like this:</p>
                <pre class="mcq-example">
[Subject: Math]
[Chapter: Algebra]
[Lesson: Linear Equations]
[Board: CBSE]
[isQuizzable: true]
[Tags: easy, calculation]
1. What is the solution to 2x + 3 = 7?
a) 1
b) 2
c) 3
d) 4
Correct: b
Explanation: To solve 2x + 3 = 7, subtract 3 from both sides to get 2x = 4, then divide by 2 to find x = 2. Thus, the correct answer is option b.
                </pre>
                <textarea id="mcqInput" placeholder="Paste your questions here..."></textarea>
                <button id="parseBtn">Parse Questions</button>
                <button id="clearImportBtn" class="danger">Clear</button>
            </div>
        </div>

        <div class="tab-content" id="bank-tab">
            <div class="panel">
                <h2>Question Bank</h2>
                <div class="stats">
                    <div class="stat-item">
                        <div class="stat-value" id="totalQuestions">0</div>
                        <div>Total Questions</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="subjectsCount">0</div>
                        <div>Subjects</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="chaptersCount">0</div>
                        <div>Chapters</div>
                    </div>
                </div>

                <div class="detailed-stats">
                    <h3>Detailed Counts</h3>
                    <div id="detailedStatsContent"></div>
                </div>
                <div class="search-filters">
                    <div>
                        <label for="searchText">Search Text:</label>
                        <input type="text" id="searchText" placeholder="Enter keywords...">
                    </div>
                    <div>
                        <label for="filterSubject">Subject:</label>
                        <select id="filterSubject">
                            <option value="">All Subjects</option>
                        </select>
                    </div>
                    <div>
                        <label for="filterChapter">Chapter:</label>
                        <select id="filterChapter">
                            <option value="">All Chapters</option>
                        </select>
                    </div>
                    <div>
                        <label for="filterLesson">Lesson:</label>
                        <select id="filterLesson">
                            <option value="">All Lessons</option>
                        </select>
                    </div>
                    <div>
                        <label for="filterType">Type:</label>
                        <select id="filterType">
                            <option value="">All Types</option>
                            <option value="mcq">MCQ</option>
                            <option value="cq">CQ</option>
                            <option value="sq">SQ</option>
                        </select>
                    </div>
                    <div>
                        <label for="filterBoard">Board:</label>
                        <select id="filterBoard">
                            <option value="">All Boards</option>
                        </select>
                    </div>
                    <div>
                        <label for="filterQuizzable">Quizzable:</label>
                        <select id="filterQuizzable">
                            <option value="">All</option>
                            <option value="true">Quizzable</option>
                            <option value="false">Non-Quizzable</option>
                        </select>
                    </div>
                    <div>
                        <label for="filterLanguage">Language:</label>
                        <select id="filterLanguage">
                            <option value="">All Languages</option>
                            <option value="en">English</option>
                            <option value="bn">Bangla</option>
                        </select>
                    </div>
                </div>
                <button id="applyFiltersBtn">Apply Filters</button>
                <button id="resetFiltersBtn" class="secondary">Reset Filters</button>
                <div id="questionsContainer"></div>
            </div>
        </div>

        <div class="tab-content" id="add-tab">
            <div class="panel">
                <h2>Add/Edit Question</h2>
                <input type="hidden" id="editQuestionId">
                <div>
                    <label for="questionType">Question Type:</label>
                    <select id="questionType">
                        <option value="mcq">MCQ</option>
                        <option value="cq">CQ</option>
                        <option value="sq">SQ</option>
                    </select>
                </div>
                <div class="metadata-fields">
                    <div>
                        <label for="subject">Subject:</label>
                        <input type="text" id="subject" placeholder="e.g., Mathematics">
                    </div>
                    <div>
                        <label for="chapter">Chapter:</label>
                        <input type="text" id="chapter" placeholder="e.g., Algebra">
                    </div>
                    <div>
                        <label for="lesson">Lesson:</label>
                        <input type="text" id="lesson" placeholder="e.g., Linear Equations">
                    </div>
                    <div>
                        <label for="board">Board:</label>
                        <input type="text" id="board" placeholder="e.g., DB24, JB21, SB20">
                    </div>
                    <div>
                        <label for="isQuizzable">Quizzable:</label>
                        <input type="checkbox" id="isQuizzable" checked>
                        <span style="margin-left: 5px; font-size: 0.9em;">(Include in quizzes?)</span>
                    </div>
                </div>
                <div>
                    <label for="questionText">Question:</label>
                    <textarea id="questionText" placeholder="Enter your question here..."></textarea>
                </div>
                <div class="image-upload-container">
                    <label for="questionImageUpload">Question Image:</label>
                    <input type="file" id="questionImageUpload" accept="image/*">
                    <img id="questionImagePreview" class="image-preview">
                    <button id="removeQuestionImageBtn" class="danger" style="display: none; margin-top: 5px;">Remove Image</button>
                </div>

                <div class="mcq-only">
                    <div>
                        <label>Options:</label>
                        <div class="option-fields">
                            <div>
                                <input type="text" class="option" placeholder="Option a)" data-option="a">
                                <div class="option-image-upload">
                                    <label>Image for a:</label>
                                    <input type="file" class="option-image-upload-input" data-option="a" accept="image/*">
                                    <img class="option-image-preview" data-option="a">
                                    <button class="remove-option-image-btn danger" data-option="a" style="display: none; margin-top: 5px;">Remove</button>
                                </div>
                            </div>
                            <div>
                                <input type="text" class="option" placeholder="Option b)" data-option="b">
                                <div class="option-image-upload">
                                    <label>Image for b:</label>
                                    <input type="file" class="option-image-upload-input" data-option="b" accept="image/*">
                                    <img class="option-image-preview" data-option="b">
                                    <button class="remove-option-image-btn danger" data-option="b" style="display: none; margin-top: 5px;">Remove</button>
                                </div>
                            </div>
                            <div>
                                <input type="text" class="option" placeholder="Option c)" data-option="c">
                                <div class="option-image-upload">
                                    <label>Image for c:</label>
                                    <input type="file" class="option-image-upload-input" data-option="c" accept="image/*">
                                    <img class="option-image-preview" data-option="c">
                                    <button class="remove-option-image-btn danger" data-option="c" style="display: none; margin-top: 5px;">Remove</button>
                                </div>
                            </div>
                            <div>
                                <input type="text" class="option" placeholder="Option d)" data-option="d">
                                <div class="option-image-upload">
                                    <label>Image for d:</label>
                                    <input type="file" class="option-image-upload-input" data-option="d" accept="image/*">
                                    <img class="option-image-preview" data-option="d">
                                    <button class="remove-option-image-btn danger" data-option="d" style="display: none; margin-top: 5px;">Remove</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    <label for="correctAnswer">Correct Answer:</label>
                    <select id="correctAnswer">
                        <option value="">Select correct answer</option>
                        <option value="a">Option a</option>
                        <option value="b">Option b</option>
                        <option value="c">Option c</option>
                        <option value="d">Option d</option>
                    </select>
                    <div>
                        <label for="explanation">Explanation:</label>
                        <textarea id="explanation" placeholder="Enter the explanation for the correct answer..."></textarea>
                    </div>
                </div>

                <div class="cq-only">
                    <div>
                        <label>Parts:</label>
                        <div class="option-fields">
                            <div>
                                <input type="text" class="option" placeholder="Part a) text" data-option="a">
                                <input type="number" class="part-marks" placeholder="Marks" data-option="a" min="0">
                                <textarea class="part-answer" placeholder="Answer for part a" data-option="a"></textarea>
                                <div class="option-image-upload">
                                    <label>Image for a:</label>
                                    <input type="file" class="option-image-upload-input" data-option="a" accept="image/*">
                                    <img class="option-image-preview" data-option="a">
                                    <button class="remove-option-image-btn danger" data-option="a" style="display: none; margin-top: 5px;">Remove</button>
                                </div>
                            </div>
                            <div>
                                <input type="text" class="option" placeholder="Part b) text" data-option="b">
                                <input type="number" class="part-marks" placeholder="Marks" data-option="b" min="0">
                                <textarea class="part-answer" placeholder="Answer for part b" data-option="b"></textarea>
                                <div class="option-image-upload">
                                    <label>Image for b:</label>
                                    <input type="file" class="option-image-upload-input" data-option="b" accept="image/*">
                                    <img class="option-image-preview" data-option="b">
                                    <button class="remove-option-image-btn danger" data-option="b" style="display: none; margin-top: 5px;">Remove</button>
                                </div>
                            </div>
                            <div>
                                <input type="text" class="option" placeholder="Part c) text" data-option="c">
                                <input type="number" class="part-marks" placeholder="Marks" data-option="c" min="0">
                                <textarea class="part-answer" placeholder="Answer for part c" data-option="c"></textarea>
                                <div class="option-image-upload">
                                    <label>Image for c:</label>
                                    <input type="file" class="option-image-upload-input" data-option="c" accept="image/*">
                                    <img class="option-image-preview" data-option="c">
                                    <button class="remove-option-image-btn danger" data-option="c" style="display: none; margin-top: 5px;">Remove</button>
                                </div>
                            </div>
                            <div>
                                <input type="text" class="option" placeholder="Part d) text" data-option="d">
                                <input type="number" class="part-marks" placeholder="Marks" data-option="d" min="0">
                                <textarea class="part-answer" placeholder="Answer for part d" data-option="d"></textarea>
                                <div class="option-image-upload">
                                    <label>Image for d:</label>
                                    <input type="file" class="option-image-upload-input" data-option="d" accept="image/*">
                                    <img class="option-image-preview" data-option="d">
                                    <button class="remove-option-image-btn danger" data-option="d" style="display: none; margin-top: 5px;">Remove</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="sq-only">
                    <div>
                        <label for="sqAnswer">Answer:</label>
                        <textarea id="sqAnswer" class="sq-answer" placeholder="Enter the answer to the short question here..."></textarea>
                    </div>
                </div>

                <div>
                    <label for="tags">Tags (comma separated):</label>
                    <input type="text" id="tags" placeholder="e.g., easy, formula, calculation">
                </div>
                <button id="saveQuestionBtn">Save Question</button>
                <button id="cancelEditBtn" class="danger" style="display:none;">Cancel Edit</button>
            </div>
        </div>

        <div class="tab-content" id="cq-tab">
            <div class="panel">
                <h2>Bulk Import Constructive Questions (CQ)</h2>
                <p>Format your questions like this example:</p>
                <div class="format-example">
                    <pre style="white-space: pre-wrap; word-wrap: break-word; overflow-x: auto; background: #f5f5f5; padding: 15px; border-radius: 4px; max-height: 300px;">
Question 1
[There is a picture]
Organelle M and N are marked in the diagram.
a. What is plasmalemma? (1)
b. Why are plastids called colour forming organs? (2)
c. Why is the organelle marked with N important for the living world? Explain. (3)
d. What types of problem will appear in living bodies if the part marked with M is absent? Analyse it. (4)

Answer:
a. The protoplasm of the living cell remains surrounded by a bilayered selectively permeable membrane known as plasmalemma or cell membrane.
b. The coloured organelles present within the cytoplasm of plant cells are known as plastids. They are responsible for the formation of colour of any plant part like leaves, flower and fruits. In absence of light plastids become colourless.
c. The N marked organelle is the chloroplast. Plants trap light energy by the chloroplast to manufacture carbohydrate food, releasing oxygen. This maintains oxygen balance and provides energy for living organisms.
d. The M-marked part is the centriole. If absent, cell division in animals would stop, halting growth and development as chromatids cannot separate during mitosis.
Subject: Biology
Chapter: Cell Structure and Function
Lesson: Organelles and Their Roles
Board: CBSE
isQuizzable: true
Tags: cell, organelle
                    </pre>
                </div>
                <textarea id="cqInput" placeholder="Paste your CQ questions here..."></textarea>
                <div class="button-group">
                    <button id="parseCqBtn" style="margin-top: 10px;">Parse CQ Questions</button>
                    <button id="clearCqBtn" class="danger" style="margin-top: 10px;">Clear</button>
                </div>
            </div>
        </div>

        <div class="tab-content" id="sq-tab">
            <div class="panel">
                <h2>Bulk Import Short Questions (SQ)</h2>
                <p>Format your questions like this example:</p>
                <div class="format-example">
                    <pre style="white-space: pre-wrap; word-wrap: break-word; overflow-x: auto; background: #f5f5f5; padding: 15px; border-radius: 4px; max-height: 300px;">
[Subject: Physics]
[Chapter: Laws of Motion]
[Lesson: Newton's First Law]
[isQuizzable: true]
[Board: DB24]
[Tags: fundamental, theory]
1. What does Newton's First Law of Motion state?
Answer: Newton's First Law, also called the Law of Inertia, states that an object at rest will remain at rest, and an object in motion will continue moving at a constant velocity in a straight line, unless acted upon by an external unbalanced force. This law introduces the concept of inertia as a property of matter that resists changes to its state of motion.
                    </pre>
                </div>
                <textarea id="sqInput" placeholder="Paste your SQ questions here..."></textarea>
                <div class="button-group">
                    <button id="parseSqBtn" style="margin-top: 10px;">Parse SQ Questions</button>
                    <button id="clearSqBtn" class="danger" style="margin-top: 10px;">Clear</button>
                </div>
            </div>
        </div>

        <div class="tab-content" id="import-bn-tab">
            <div class="panel">
                <h2>Bulk Import Bangla Questions</h2>
                <p>Format your questions like this:</p>
                <pre class="mcq-example">
[Subject: Math]
[Chapter: Algebra]
[Lesson: Linear Equations]
[Board: CBSE]
[isQuizzable: true]
[Tags: easy, calculation]
1. 2x + 3 = 7 এর সমাধান কী?
a) 1
b) 2
c) 3
d) 4
Correct: b
Explanation: 2x + 3 = 7 সমাধান করতে, উভয় পাশ থেকে 3 বিয়োগ করুন এবং তারপর 2 দ্বারা ভাগ করুন। সুতরাং, সঠিক উত্তর হল b।
                </pre>
                <textarea id="mcqInputBn" placeholder="Paste your Bangla questions here..."></textarea>
                <button id="parseBtnBn">Parse Bangla Questions</button>
                <button id="clearImportBtnBn" class="danger">Clear</button>
            </div>
        </div>

        <div class="tab-content" id="cq-bn-tab">
            <div class="panel">
                <h2>Bulk Import Bangla Constructive Questions (CQ)</h2>
                <p>Format your questions like this example:</p>
                <div class="format-example">
                    <pre style="white-space: pre-wrap; word-wrap: break-word; overflow-x: auto; background: #f5f5f5; padding: 15px; border-radius: 4px; max-height: 300px;">
প্রশ্ন 1
ডায়াগ্রামে অর্গানেল M এবং N চিহ্নিত করা হয়েছে।
a. প্লাজমালেমা কী? (1)
b. প্লাস্টিডগুলিকে কেন রঙ গঠনকারী অঙ্গ বলা হয়? (2)
c. N চিহ্নিত অর্গানেলটি জীবজগতের জন্য কেন গুরুত্বপূর্ণ? ব্যাখ্যা করুন। (3)
d. M চিহ্নিত অংশ অনুপস্থিত থাকলে জীবদেহে কী ধরনের সমস্যা দেখা দেবে? বিশ্লেষণ করুন। (4)

উত্তর:
a. জীবকোষের প্রোটোপ্লাজম একটি দ্বিস্তরীয় নির্বাচনীভাবে প্রবেশযোগ্য ঝিল্লি দ্বারা ঘেরা থাকে, যা প্লাজমালেমা বা কোষঝিল্লি নামে পরিচিত।
b. উদ্ভিদ কোষের সাইটোপ্লাজমে উপস্থিত রঙিন অর্গানেলগুলি প্লাস্টিড নামে পরিচিত। এগুলি উদ্ভিদের পাতা, ফুল এবং ফলের রঙ গঠনের জন্য দায়ী।
c. N চিহ্নিত অর্গানেলটি হল ক্লোরোপ্লাস্ট। উদ্ভিদ ক্লোরোপ্লাস্ট দ্বারা আলোক শক্তি ধরে রাখে এবং অক্সিজেন নির্গত করে।
d. M চিহ্নিত অংশটি হল সেন্ট্রিওল। এটি অনুপস্থিত থাকলে প্রাণীকোষে কোষ বিভাজন বন্ধ হয়ে যাবে।
Subject: Biology
Chapter: Cell Structure and Function
Lesson: Organelles and Their Roles  Board: CBSE
isQuizzable: true
Tags: cell, organelle
                    </pre>
                </div>
                <textarea id="cqInputBn" placeholder="Paste your Bangla CQ questions here..."></textarea>
                <div class="button-group">
                    <button id="parseCqBtnBn" style="margin-top: 10px;">Parse Bangla CQ Questions</button>
                    <button id="clearCqBtnBn" class="danger" style="margin-top: 10px;">Clear</button>
                </div>
            </div>
        </div>

        <div class="tab-content" id="sq-bn-tab">
            <div class="panel">
                <h2>Bulk Import Bangla Short Questions (SQ)</h2>
                <p>Format your questions like this example:</p>
                <div class="format-example">
                    <pre style="white-space: pre-wrap; word-wrap: break-word; overflow-x: auto; background: #f5f5f5; padding: 15px; border-radius: 4px; max-height: 300px;">
[Subject: Physics]
[Chapter: Laws of Motion]
[Lesson: Newton's First Law]
[isQuizzable: true]
[Board: DB24]
[Tags: fundamental, theory]
1. নিউটনের প্রথম গতিসূত্র কী বলে?
Answer: নিউটনের প্রথম গতিসূত্র, যা জড়তার সূত্র নামেও পরিচিত, বলে যে কোনও বস্তু বিশ্রামে থাকলে বিশ্রামে থাকবে এবং গতিশীল থাকলে স্থির বেগে সরলরেখায় চলতে থাকবে, যদি না কোনও বাহ্যিক অসমতুলিত বল এটির উপর কাজ করে।
                    </pre>
                </div>
                <textarea id="sqInputBn" placeholder="Paste your Bangla SQ questions here..."></textarea>
                <div class="button-group">
                    <button id="parseSqBtnBn" style="margin-top: 10px;">Parse Bangla SQ Questions</button>
                    <button id="clearSqBtnBn" class="danger" style="margin-top: 10px;">Clear</button>
                </div>
            </div>
        </div>


    <script>
    
    document.addEventListener('DOMContentLoaded', async function() {
        const CORRECT_PASSWORD = 'EdVenture';
        const passwordOverlay = document.getElementById('password-overlay');
        const passwordInput = document.getElementById('password-input');
        const passwordSubmit = document.getElementById('password-submit');

        passwordSubmit.addEventListener('click', function() {
            if (passwordInput.value === CORRECT_PASSWORD) {
                passwordOverlay.style.display = 'none';
                initializeApplication();
            } else {
                alert('Incorrect password. Please try again.');
                passwordInput.value = '';
            }
        });

        passwordInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                passwordSubmit.click();
            }
        });

        // Supabase Initialization
        const createClient = supabase.createClient;
        const supabaseUrl = 'https://idgogbisqacywbfnhdzy.supabase.co';
        const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImlkZ29nYmlzcWFjeXdiZm5oZHp5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTIzMjAxODMsImV4cCI6MjA2Nzg5NjE4M30.vPUQowhkQVLcQQziELxvLt3cz0QO8cBonxQwIYcjJHs';
        let supabaseClient = null;
        const BUCKET_NAME = 'questionimages';

        async function initSupabase() {
            try {
                console.log("Attempting to connect to Supabase...");
                supabaseClient = createClient(supabaseUrl, supabaseKey);
                const { data, error } = await supabaseClient.from('questions').select('*').limit(1);
                if (error) throw error;
                console.log("✅ Supabase connection test successful!");
                return true;
            } catch (err) {
                console.warn("❌ Supabase connection failed:", err.message);
                alert('Failed to connect to Supabase: ' + err.message);
                supabaseClient = null;
                return false;
            }
        }

        const CHUNK_SIZE = 20;
        const tabs = document.querySelectorAll('.tab');
        const tabContents = document.querySelectorAll('.tab-content');
        const mcqInput = document.getElementById('mcqInput');
        const parseBtn = document.getElementById('parseBtn');
        const clearImportBtn = document.getElementById('clearImportBtn');
        const questionsContainer = document.getElementById('questionsContainer');
        const searchText = document.getElementById('searchText');
        const filterSubject = document.getElementById('filterSubject');
        const filterChapter = document.getElementById('filterChapter');
        const filterLesson = document.getElementById('filterLesson');
        const filterType = document.getElementById('filterType');
        const filterBoard = document.getElementById('filterBoard');
        const filterQuizzable = document.getElementById('filterQuizzable');
        const filterLanguage = document.getElementById('filterLanguage');
        const applyFiltersBtn = document.getElementById('applyFiltersBtn');
        const resetFiltersBtn = document.getElementById('resetFiltersBtn');
        const saveQuestionBtn = document.getElementById('saveQuestionBtn');
        const cancelEditBtn = document.getElementById('cancelEditBtn');
        const exportBtn = document.getElementById('exportBtn');
        const importBtn = document.getElementById('importBtn');
        const editQuestionId = document.getElementById('editQuestionId');
        const questionType = document.getElementById('questionType');
        const subjectInput = document.getElementById('subject');
        const chapterInput = document.getElementById('chapter');
        const lessonInput = document.getElementById('lesson');
        const boardInput = document.getElementById('board');
        const isQuizzableInput = document.getElementById('isQuizzable');
        const questionTextInput = document.getElementById('questionText');
        const optionInputs = document.querySelectorAll('.option');
        const correctAnswerSelect = document.getElementById('correctAnswer');
        const tagsInput = document.getElementById('tags');
        const questionImageUpload = document.getElementById('questionImageUpload');
        const questionImagePreview = document.getElementById('questionImagePreview');
        const removeQuestionImageBtn = document.getElementById('removeQuestionImageBtn');
        const optionImageUploadInputs = document.querySelectorAll('.option-image-upload-input');
        const optionImagePreviews = document.querySelectorAll('.option-image-preview');
        const removeOptionImageBtns = document.querySelectorAll('.remove-option-image-btn');
        const totalQuestionsEl = document.getElementById('totalQuestions');
        const subjectsCountEl = document.getElementById('subjectsCount');
        const chaptersCountEl = document.getElementById('chaptersCount');
        const cqInput = document.getElementById('cqInput');
        const parseCqBtn = document.getElementById('parseCqBtn');
        const clearCqBtn = document.getElementById('clearCqBtn');
        const detailedStatsContent = document.getElementById('detailedStatsContent');
        const sqInput = document.getElementById('sqInput');
        const parseSqBtn = document.getElementById('parseSqBtn');
        const clearSqBtn = document.getElementById('clearSqBtn');
        const sqAnswerInput = document.getElementById('sqAnswer');
        const explanationInput = document.getElementById('explanation');
        const mcqInputBn = document.getElementById('mcqInputBn');
        const parseBtnBn = document.getElementById('parseBtnBn');
        const clearImportBtnBn = document.getElementById('clearImportBtnBn');
        const cqInputBn = document.getElementById('cqInputBn');
        const parseCqBtnBn = document.getElementById('parseCqBtnBn');
        const clearCqBtnBn = document.getElementById('clearCqBtnBn');
        const sqInputBn = document.getElementById('sqInputBn');
        const parseSqBtnBn = document.getElementById('parseSqBtnBn');
        const clearSqBtnBn = document.getElementById('clearSqBtnBn');

        let questionBank = [];
        let currentFilters = {};

        function initializeApplication() {
            const criticalElements = [
                'mcqInput', 'parseBtn', 'questionsContainer', 'saveQuestionBtn',
                'questionType', 'questionText', 'totalQuestions', 'board', 'isQuizzable',
                'detailedStatsContent', 'sqInput', 'parseSqBtn', 'sqAnswer',
                'mcqInputBn', 'parseBtnBn', 'cqInputBn', 'parseCqBtnBn', 'sqInputBn', 'parseSqBtnBn'
            ];

            for (const elementId of criticalElements) {
                if (!document.getElementById(elementId)) {
                    console.error(`Critical element missing: ${elementId}`);
                    alert(`Error: Missing element with ID '${elementId}'. Please check your HTML.`);
                    return;
                }
            }

            function setFormType(type) {
                const panel = document.querySelector('#add-tab .panel');
                panel.classList.remove('editing-mcq', 'editing-cq', 'editing-sq');
                panel.classList.add(`editing-${type}`);
            }

            tabs.forEach(tab => {
                tab.addEventListener('click', (e) => {
                    e.preventDefault();
                    const tabName = tab.dataset.tab;
                    tabs.forEach(t => t.classList.remove('active'));
                    tabContents.forEach(content => content.classList.remove('active'));
                    tab.classList.add('active');
                    const targetContent = document.getElementById(`${tabName}-tab`);
                    if (targetContent) {
                        targetContent.classList.add('active');
                    }
                });
            });

            async function loadQuestions() {
                if (!supabaseClient) {
                    console.error('Supabase client not available. Cannot load questions.');
                    alert('Supabase is not connected. Cannot load questions from the database.');
                    return [];
                }

                try {
                    const { data, error } = await supabaseClient
                        .from('questions')
                        .select('*')
                        .order('created_at', { ascending: false });
                    if (error) throw error;

                    const loadedQuestions = data.map(q => ({
                        ...q,
                        language: q.language || 'en', // Default to 'en' for existing questions
                        synced: true,
                        correctAnswer: q.correct_answer || null,
                        question: q.type === 'cq' ? q.question_text : q.question,
                        questionText: q.type === 'cq' ? q.question_text : null,
                        isQuizzable: q.is_quizzable !== false,
                        options: q.options || null,
                        parts: q.parts || null,
                        answer: q.answer || null,
                        explanation: q.explanation || null,
                        image: q.image || null,
                        answerimage1: q.answerimage1 || null,
                        answerimage2: q.answerimage2 || null,
                        tags: q.tags || []
                    }));

                    console.log('Loaded questions from Supabase:', loadedQuestions.length);
                    return loadedQuestions;
                } catch (error) {
                    console.error('Error loading from Supabase:', error);
                    alert('Failed to load questions from Supabase. Please check your network connection or Supabase configuration.');
                    return [];
                }
            }

            async function uploadImage(file, path) {
                if (!supabaseClient) {
                    console.warn('Supabase client not initialized. Cannot upload image.');
                    alert('Supabase is not connected. Image upload failed.');
                    return null;
                }

                const fileName = `${Date.now()}-${file.name.replace(/\s/g, '_')}`;
                const filePath = `${path}/${fileName}`;

                try {
                    const { data, error } = await supabaseClient.storage
                        .from(BUCKET_NAME)
                        .upload(filePath, file, {
                            cacheControl: '3600',
                            upsert: false
                        });

                    if (error) throw error;

                    const { data: publicUrlData } = supabaseClient.storage
                        .from(BUCKET_NAME)
                        .getPublicUrl(filePath);

                    if (publicUrlData && publicUrlData.publicUrl) {
                        console.log('Image uploaded successfully:', publicUrlData.publicUrl);
                        return publicUrlData.publicUrl;
                    } else {
                        throw new Error('Failed to retrieve public URL after upload.');
                    }
                } catch (error) {
                    console.error('Supabase Storage upload error:', error.message);
                    alert(`Error uploading image: ${error.message}`);
                    return null;
                }
            }

            async function deleteImage(url) {
                if (!supabaseClient || !url || !url.includes(BUCKET_NAME)) {
                    console.warn('Supabase client not initialized or invalid URL for deletion.');
                    return;
                }

                try {
                    const pathParts = url.split(BUCKET_NAME + '/public/');
                    if (pathParts.length < 2) {
                        console.warn('Could not extract valid path from image URL for deletion:', url);
                        return;
                    }
                    const filePath = pathParts[1];

                    const { data, error } = await supabaseClient.storage
                        .from(BUCKET_NAME)
                        .remove([filePath]);

                    if (error) throw error;
                    console.log('Image deleted from Supabase Storage:', filePath, data);
                } catch (error) {
                    console.error('Supabase Storage deletion error:', error.message);
                    alert(`Error deleting image: ${error.message}`);
                }
            }

            function isDuplicateQuestion(newQuestion) {
                return questionBank.some(existingQuestion => {
                    if (existingQuestion.type !== newQuestion.type) {
                        return false;
                    }

                    if (newQuestion.type === 'mcq' || newQuestion.type === 'sq') {
                        const newQuestionText = (newQuestion.question || '').toLowerCase().trim();
                        const existingQuestionText = (existingQuestion.question || '').toLowerCase().trim();
                        return newQuestionText === existingQuestionText;
                    } else if (newQuestion.type === 'cq') {
                        const newCQText = (newQuestion.questionText || '').toLowerCase().trim();
                        const existingCQText = (existingQuestion.questionText || '').toLowerCase().trim();

                        if (newCQText !== existingCQText) {
                            return false;
                        }

                        if (newQuestion.parts.length !== existingQuestion.parts.length) {
                            return false;
                        }

                        return newQuestion.parts.every((newPart, index) => {
                            const existingPart = existingQuestion.parts[index];
                            return (newPart.text || '').toLowerCase().trim() === (existingPart.text || '').toLowerCase().trim();
                        });
                    }
                    return false;
                });
            }

            async function parseMCQs() {
                const text = mcqInput.value.trim();
                if (!text) {
                    alert('Please enter questions to import.');
                    return;
                }

                const blocks = text.split(/(?=\n*\[Subject:|\n*\d+\.\s)/).filter(b => b.trim());
                const newQuestions = [];
                const skippedQuestions = [];
                let currentMetadata = {
                    subject: '',
                    chapter: '',
                    lesson: '',
                    board: '',
                    isQuizzable: true,
                    tags: ['mcq']
                };

                for (const block of blocks) {
                    const lines = block.split('\n').map(l => l.trim()).filter(l => l);
                    if (!lines.length) continue;

                    if (lines[0].startsWith('[')) {
                        lines.forEach(line => {
                            if (line.startsWith('[Subject:')) currentMetadata.subject = line.replace('[Subject:', '').replace(']', '').trim();
                            else if (line.startsWith('[Chapter:')) currentMetadata.chapter = line.replace('[Chapter:', '').replace(']', '').trim();
                            else if (line.startsWith('[Lesson:')) currentMetadata.lesson = line.replace('[Lesson:', '').replace(']', '').trim();
                            else if (line.startsWith('[Board:')) currentMetadata.board = line.replace('[Board:', '').replace(']', '').trim();
                            else if (line.startsWith('[isQuizzable:')) currentMetadata.isQuizzable = line.replace('[isQuizzable:', '').replace(']', '').trim().toLowerCase() === 'true';
                            else if (line.startsWith('[Tags:')) {
                                const tags = line.replace('[Tags:', '').replace(']', '').trim();
                                currentMetadata.tags = ['mcq', ...tags.split(',').map(t => t.trim()).filter(t => t && t !== 'mcq')];
                            }
                        });
                        continue;
                    }

                    const question = {
                        ...currentMetadata,
                        id: Date.now() + Math.floor(Math.random() * 1000),
                        type: 'mcq',
                        question: '',
                        options: [],
                        correctAnswer: '',
                        explanation: '',
                        image: null,
                        synced: false
                    };

                    let questionTextLines = [];
                    let parsingOptions = false;
                    let parsingCorrectAnswer = false;
                    let parsingExplanation = false;
                    let explanationLines = [];

                    for (const line of lines) {
                        if (/^\d+\.\s/.test(line) && !parsingOptions && !parsingCorrectAnswer && !parsingExplanation) {
                            questionTextLines.push(line.replace(/^\d+\.\s/, '').trim());
                        } else if (/^\s*([a-dA-D])[\).\s]\s*(.*)/i.test(line) && !parsingCorrectAnswer && !parsingExplanation) {
                            parsingOptions = true;
                            const match = line.match(/^\s*([a-dA-D])[\).\s]\s*(.*)/i);
                            if (match) {
                                const label = match[1].toLowerCase();
                                const text = match[2].trim();
                                question.options.push({ label, text: `${label}) ${text}`, image: null });
                            }
                        } else if (/^Correct:\s*([a-dA-D])/i.test(line) && !parsingExplanation) {
                            parsingOptions = false;
                            parsingCorrectAnswer = true;
                            const match = line.match(/^Correct:\s*([a-dA-D])/i);
                            if (match) question.correctAnswer = match[1].toLowerCase();
                        } else if (/^Explanation:/i.test(line)) {
                            parsingCorrectAnswer = false;
                            parsingExplanation = true;
                            explanationLines.push(line.replace(/^Explanation:/i, '').trim());
                        } else if (parsingExplanation && line.trim()) {
                            explanationLines.push(line);
                        } else if (!parsingOptions && !parsingCorrectAnswer && !parsingExplanation && line.trim()) {
                            questionTextLines.push(line);
                        }
                    }

                    question.question = questionTextLines.join('\n').trim();
                    question.explanation = explanationLines.join('\n').trim();

                    if (question.question && question.options.length >= 2 && question.correctAnswer) {
                        if (!isDuplicateQuestion(question)) {
                            newQuestions.push(question);
                        } else {
                            skippedQuestions.push(question);
                        }
                    }
                }

                if (newQuestions.length > 0) {
                    let successfulUploads = 0;
                    let skippedCount = skippedQuestions.length;
                    let failedUploads = 0;

                    for (let i = 0; i < newQuestions.length; i += CHUNK_SIZE) {
                        const chunk = newQuestions.slice(i, i + CHUNK_SIZE);
                        const chunkResults = await processChunk(chunk);

                        successfulUploads += chunkResults.successful;
                        skippedCount += chunkResults.skipped;
                        failedUploads += chunkResults.failed;
                    }

                    let message = `Processed ${newQuestions.length + skippedCount} questions:`;
                    message += `\n✅ ${successfulUploads} successfully uploaded`;
                    message += `\n🚫 ${skippedCount} duplicates skipped`;
                    message += `\n❌ ${failedUploads} failed to upload`;

                    alert(message);
                    resetFilters();
                    renderQuestionBank();
                    mcqInput.value = '';
                    document.querySelector('.tab[data-tab="bank"]').click();
                } else if (skippedQuestions.length > 0) {
                    alert(`No new MCQ questions imported. ${skippedQuestions.length} duplicate MCQ questions were skipped.`);
                } else {
                    alert('No valid MCQ questions found. Please check your format.');
                }
            }

            async function parseCQs() {
                const text = cqInput.value.trim();
                if (!text) {
                    alert('Please enter constructive questions to import.');
                    return;
                }

                const lines = text.split('\n').map(l => l.trim());
                const newQuestions = [];
                const skippedQuestions = [];
                let currentQuestion = null;
                let globalMetadata = { subject: '', chapter: '', lesson: '', board: '', isQuizzable: true, tags: ['cq'] };
                let inAnswerSection = false;
                let currentPartLetter = null;
                let currentPartAnswerBuffer = [];
                let questionTextBuffer = [];

                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    if (line.length === 0 && !inAnswerSection) continue;

                    const metadataMatch = line.match(/^(Subject|Chapter|Lesson|Board|isQuizzable|Tags):\s*(.*)$/i) || line.match(/^\[(Subject|Chapter|Lesson|Board|isQuizzable|Tags):\s*(.*?)\]$/i);
                    if (metadataMatch) {
                        const key = metadataMatch[1].toLowerCase();
                        let value = metadataMatch[2].trim();
                        if (key === 'isquizzable') value = value.toLowerCase() === 'true';
                        else if (key === 'tags') value = ['cq', ...value.split(',').map(t => t.trim()).filter(t => t && t !== 'cq')];

                        if (currentQuestion) {
                            currentQuestion[key] = value;
                        } else {
                            globalMetadata[key] = value;
                        }
                        continue;
                    }

                    if (/^Question\s+\d+/i.test(line)) {
                        if (currentQuestion) {
                            if (inAnswerSection && currentPartLetter && currentPartAnswerBuffer.length) {
                                const part = currentQuestion.parts.find(p => p.letter === currentPartLetter);
                                if (part) part.answer = currentPartAnswerBuffer.join('\n').trim();
                            }
                            if (currentQuestion.questionText && currentQuestion.parts.length > 0 && currentQuestion.parts.every(p => p.answer)) {
                                if (!isDuplicateQuestion(currentQuestion)) {
                                    newQuestions.push(currentQuestion);
                                } else {
                                    skippedQuestions.push(currentQuestion);
                                }
                            } else {
                                console.warn("Skipping incomplete question:", currentQuestion);
                            }
                        }
                        currentQuestion = {
                            ...globalMetadata,
                            id: Date.now() + Math.floor(Math.random() * 1000),
                            type: 'cq',
                            questionText: '',
                            image: null,
                            answerimage1: null,
                            answerimage2: null,
                            parts: [],
                            synced: false
                        };
                        inAnswerSection = false;
                        currentPartLetter = null;
                        currentPartAnswerBuffer = [];
                        questionTextBuffer = [];
                        continue;
                    }

                    if (line.toLowerCase() === 'answer:') {
                        inAnswerSection = true;
                        currentQuestion.questionText = questionTextBuffer.join('\n').trim();
                        questionTextBuffer = [];
                        continue;
                    }

                    if (!inAnswerSection) {
                        const partMatch = line.match(/^([a-d])\.\s*(.*?)\s*\((\d+)\)\s*$/i);
                        if (partMatch) {
                            if (!currentQuestion) {
                                currentQuestion = {
                                    ...globalMetadata,
                                    id: Date.now() + Math.floor(Math.random() * 1000),
                                    type: 'cq',
                                    questionText: '',
                                    image: null,
                                    answerimage1: null,
                                    answerimage2: null,
                                    parts: [],
                                    synced: false
                                };
                            }
                            const partLetter = partMatch[1].toLowerCase();
                            currentQuestion.parts.push({ letter: partMatch[1].toLowerCase(), text: partMatch[2].trim(), marks: parseInt(partMatch[3]), answer: '', image: null });
                            if (i + 1 < lines.length && lines[i + 1].trim() === `[There is a picture for part ${partLetter}]`) {
                                if (partLetter === 'c') {
                                    currentQuestion.answerimage1 = '[There is a picture for part c]';
                                } else if (partLetter === 'd') {
                                    currentQuestion.answerimage2 = '[There is a picture for part d]';
                                }
                                i++;
                            }
                        } else if (!line.startsWith('[There is a picture]')) {
                            questionTextBuffer.push(line);
                        }
                    } else {
                        const answerPartMatch = line.match(/^([a-d])\.\s*(.*)$/i);
                        if (answerPartMatch) {
                            if (currentPartLetter && currentPartAnswerBuffer.length) {
                                const part = currentQuestion.parts.find(p => p.letter === currentPartLetter);
                                if (part) part.answer = currentPartAnswerBuffer.join('\n').trim();
                            }
                            currentPartLetter = answerPartMatch[1].toLowerCase();
                            currentPartAnswerBuffer = [answerPartMatch[2]];
                        } else if (currentPartLetter && line.trim() !== "") {
                            currentPartAnswerBuffer.push(line);
                        } else if (line.trim() === "" && currentPartLetter) {
                            currentPartAnswerBuffer.push(line);
                        }
                    }
                }

                if (currentQuestion) {
                    if (inAnswerSection && currentPartLetter && currentPartAnswerBuffer.length) {
                        const part = currentQuestion.parts.find(p => p.letter === currentPartLetter);
                        if (part) part.answer = currentPartAnswerBuffer.join('\n').trim();
                    }
                    if (!currentQuestion.questionText && questionTextBuffer.length) {
                        currentQuestion.questionText = questionTextBuffer.join('\n').trim();
                    }
                    if (currentQuestion.questionText && currentQuestion.parts.length > 0 && currentQuestion.parts.every(p => p.answer)) {
                        if (!isDuplicateQuestion(currentQuestion)) {
                            newQuestions.push(currentQuestion);
                        } else {
                            skippedQuestions.push(currentQuestion);
                        }
                    } else {
                        console.warn("Skipping incomplete last question:", currentQuestion);
                    }
                }

                if (newQuestions.length > 0) {
                    let successfulUploads = 0;
                    let skippedCount = skippedQuestions.length;
                    let failedUploads = 0;

                    for (let i = 0; i < newQuestions.length; i += CHUNK_SIZE) {
                        const chunk = newQuestions.slice(i, i + CHUNK_SIZE);
                        const chunkResults = await processChunk(chunk);

                        successfulUploads += chunkResults.successful;
                        skippedCount += chunkResults.skipped;
                        failedUploads += chunkResults.failed;
                    }

                    let message = `Processed ${newQuestions.length + skippedCount} questions:`;
                    message += `\n✅ ${successfulUploads} successfully uploaded`;
                    message += `\n🚫 ${skippedCount} duplicates skipped`;
                    message += `\n❌ ${failedUploads} failed to upload`;

                    alert(message);
                    resetFilters();
                    renderQuestionBank();
                    cqInput.value = '';
                    document.querySelector('.tab[data-tab="bank"]').click();
                } else if (skippedQuestions.length > 0) {
                    alert(`No new CQ questions imported. ${skippedQuestions.length} duplicate CQ questions were skipped.`);
                } else {
                    alert('No valid CQ questions found. Please check your format.');
                }
            }

            async function parseSQs() {
                const text = sqInput.value.trim();
                if (!text) {
                    alert('Please enter short questions to import.');
                    return;
                }

                const blocks = text.split(/(?=\n*\[Subject:|\n*\d+\.\s)/).filter(b => b.trim());
                const newQuestions = [];
                const skippedQuestions = [];
                let currentMetadata = {
                    subject: '',
                    chapter: '',
                    lesson: '',
                    board: '',
                    isQuizzable: true,
                    tags: ['sq']
                };

                for (const block of blocks) {
                    const lines = block.split('\n').map(l => l.trim()).filter(l => l);
                    if (!lines.length) continue;

                    if (lines[0].startsWith('[')) {
                        lines.forEach(line => {
                            if (line.startsWith('[Subject:')) currentMetadata.subject = line.replace('[Subject:', '').replace(']', '').trim();
                            else if (line.startsWith('[Chapter:')) currentMetadata.chapter = line.replace('[Chapter:', '').replace(']', '').trim();
                            else if (line.startsWith('[Lesson:')) currentMetadata.lesson = line.replace('[Lesson:', '').replace(']', '').trim();
                            else if (line.startsWith('[Board:')) currentMetadata.board = line.replace('[Board:', '').replace(']', '').trim();
                            else if (line.startsWith('[isQuizzable:')) currentMetadata.isQuizzable = line.replace('[isQuizzable:', '').replace(']', '').trim().toLowerCase() === 'true';
                            else if (line.startsWith('[Tags:')) {
                                const tags = line.replace('[Tags:', '').replace(']', '').trim();
                                currentMetadata.tags = ['sq', ...tags.split(',').map(t => t.trim()).filter(t => t && t !== 'sq')];
                            }
                        });
                        continue;
                    }

                    const question = {
                        ...currentMetadata,
                        id: Date.now() + Math.floor(Math.random() * 1000),
                        type: 'sq',
                        question: '',
                        answer: '',
                        image: null,
                        synced: false
                    };

                    let questionTextBuffer = [];
                    let answerTextBuffer = [];
                    let inAnswerSection = false;

                    for (const line of lines) {
                        if (/^\d+\.\s/.test(line) && !inAnswerSection) {
                            questionTextBuffer.push(line.replace(/^\d+\.\s/, '').trim());
                        } else if (line.toLowerCase().startsWith('answer:')) {
                            inAnswerSection = true;
                            answerTextBuffer.push(line.replace(/^Answer:/i, '').trim());
                        } else if (inAnswerSection) {
                            answerTextBuffer.push(line);
                        } else if (!inAnswerSection && line.trim()) {
                            questionTextBuffer.push(line);
                        }
                    }

                    question.question = questionTextBuffer.join('\n').trim();
                    question.answer = answerTextBuffer.join('\n').trim();

                    if (question.question && question.answer) {
                        if (!isDuplicateQuestion(question)) {
                            newQuestions.push(question);
                        } else {
                            skippedQuestions.push(question);
                        }
                    } else {
                        console.warn('Skipping incomplete SQ question:', question);
                    }
                }

                if (newQuestions.length > 0) {
                    let successfulUploads = 0;
                    let skippedCount = skippedQuestions.length;
                    let failedUploads = 0;

                    for (let i = 0; i < newQuestions.length; i += CHUNK_SIZE) {
                        const chunk = newQuestions.slice(i, i + CHUNK_SIZE);
                        const chunkResults = await processChunk(chunk);

                        successfulUploads += chunkResults.successful;
                        skippedCount += chunkResults.skipped;
                        failedUploads += chunkResults.failed;
                    }

                    let message = `Processed ${newQuestions.length + skippedCount} questions:`;
                    message += `\n✅ ${successfulUploads} successfully uploaded`;
                    message += `\n🚫 ${skippedCount} duplicates skipped`;
                    message += `\n❌ ${failedUploads} failed to upload`;

                    alert(message);
                    resetFilters();
                    renderQuestionBank();
                    sqInput.value = '';
                    document.querySelector('.tab[data-tab="bank"]').click();
                } else if (skippedQuestions.length > 0) {
                    alert(`No new SQ questions imported. ${skippedQuestions.length} duplicate SQ questions were skipped.`);
                } else {
                    alert('No valid SQ questions found. Please check your format.');
                }
            }

            async function parseMCQsBn() {
                const text = mcqInputBn.value.trim();
                if (!text) {
                    alert('Please enter Bangla questions to import.');
                    return;
                }

                const blocks = text.split(/(?=\n*\[Subject:|\n*\d+\.\s)/).filter(b => b.trim());
                const newQuestions = [];
                const skippedQuestions = [];
                let currentMetadata = {
                    subject: '',
                    chapter: '',
                    lesson: '',
                    board: '',
                    isQuizzable: true,
                    tags: ['mcq', 'bn']
                };

                for (const block of blocks) {
                    const lines = block.split('\n').map(l => l.trim()).filter(l => l);
                    if (!lines.length) continue;

                    if (lines[0].startsWith('[')) {
                        lines.forEach(line => {
                            if (line.startsWith('[Subject:')) currentMetadata.subject = line.replace('[Subject:', '').replace(']', '').trim();
                            else if (line.startsWith('[Chapter:')) currentMetadata.chapter = line.replace('[Chapter:', '').replace(']', '').trim();
                            else if (line.startsWith('[Lesson:')) currentMetadata.lesson = line.replace('[Lesson:', '').replace(']', '').trim();
                            else if (line.startsWith('[Board:')) currentMetadata.board = line.replace('[Board:', '').replace(']', '').trim();
                            else if (line.startsWith('[isQuizzable:')) currentMetadata.isQuizzable = line.replace('[isQuizzable:', '').replace(']', '').trim().toLowerCase() === 'true';
                            else if (line.startsWith('[Tags:')) {
                                const tags = line.replace('[Tags:', '').replace(']', '').trim();
                                currentMetadata.tags = ['mcq', 'bn', ...tags.split(',').map(t => t.trim()).filter(t => t && t !== 'mcq' && t !== 'bn')];
                            }
                        });
                        continue;
                    }

                    const question = {
                        ...currentMetadata,
                        id: Date.now() + Math.floor(Math.random() * 1000),
                        type: 'mcq',
                        language: 'bn',
                        question: '',
                        options: [],
                        correctAnswer: '',
                        explanation: '',
                        image: null,
                        synced: false
                    };

                    let questionTextLines = [];
                    let parsingOptions = false;
                    let parsingCorrectAnswer = false;
                    let parsingExplanation = false;
                    let explanationLines = [];

                    for (const line of lines) {
                        if (/^\d+\.\s/.test(line) && !parsingOptions && !parsingCorrectAnswer && !parsingExplanation) {
                            questionTextLines.push(line.replace(/^\d+\.\s/, '').trim());
                        } else if (/^\s*([a-dA-D])[\).\s]\s*(.*)/i.test(line) && !parsingCorrectAnswer && !parsingExplanation) {
                            parsingOptions = true;
                            const match = line.match(/^\s*([a-dA-D])[\).\s]\s*(.*)/i);
                            if (match) {
                                const label = match[1].toLowerCase();
                                const text = match[2].trim();
                                question.options.push({ label, text: `${label}) ${text}`, image: null });
                            }
                        } else if (/^Correct:\s*([a-dA-D])/i.test(line) && !parsingExplanation) {
                            parsingOptions = false;
                            parsingCorrectAnswer = true;
                            const match = line.match(/^Correct:\s*([a-dA-D])/i);
                            if (match) question.correctAnswer = match[1].toLowerCase();
                        } else if (/^Explanation:/i.test(line)) {
                            parsingCorrectAnswer = false;
                            parsingExplanation = true;
                            explanationLines.push(line.replace(/^Explanation:/i, '').trim());
                        } else if (parsingExplanation && line.trim()) {
                            explanationLines.push(line);
                        } else if (!parsingOptions && !parsingCorrectAnswer && !parsingExplanation && line.trim()) {
                            questionTextLines.push(line);
                        }
                    }

                    question.question = questionTextLines.join('\n').trim();
                    question.explanation = explanationLines.join('\n').trim();

                    if (question.question && question.options.length >= 2 && question.correctAnswer) {
                        if (!isDuplicateQuestion(question)) {
                            newQuestions.push(question);
                        } else {
                            skippedQuestions.push(question);
                        }
                    }
                }

                if (newQuestions.length > 0) {
                    let successfulUploads = 0;
                    let skippedCount = skippedQuestions.length;
                    let failedUploads = 0;

                    for (let i = 0; i < newQuestions.length; i += CHUNK_SIZE) {
                        const chunk = newQuestions.slice(i, i + CHUNK_SIZE);
                        const chunkResults = await processChunk(chunk);

                        successfulUploads += chunkResults.successful;
                        skippedCount += chunkResults.skipped;
                        failedUploads += chunkResults.failed;
                    }

                    let message = `Processed ${newQuestions.length + skippedCount} questions:`;
                    message += `\n✅ ${successfulUploads} successfully uploaded`;
                    message += `\n🚫 ${skippedCount} duplicates skipped`;
                    message += `\n❌ ${failedUploads} failed to upload`;

                    alert(message);
                    resetFilters();
                    renderQuestionBank();
                    mcqInputBn.value = '';
                    document.querySelector('.tab[data-tab="bank"]').click();
                } else if (skippedQuestions.length > 0) {
                    alert(`No new Bangla MCQ questions imported. ${skippedQuestions.length} duplicate Bangla MCQ questions were skipped.`);
                } else {
                    alert('No valid Bangla MCQ questions found. Please check your format.');
                }
            }

            // Utility function to convert Bangla digits to English numbers
            function banglaToNumber(banglaStr) {
                const banglaDigits = '০১২৩৪৫৬৭৮৯';
                const englishDigits = '0123456789';
                return parseInt(banglaStr.split('').map(char => {
                    const index = banglaDigits.indexOf(char);
                    return index !== -1 ? englishDigits[index] : char;
                }).join(''));
            }

            // Updated parseCQsBn function to handle multiple questions
            async function parseCQsBn() {
                const text = cqInputBn.value.trim();
                if (!text) {
                    alert('Please enter Bangla constructive questions to import.');
                    return;
                }

                const lines = text.split('\n').map(l => l.trim());
                const newQuestions = [];
                const skippedQuestions = [];
                let currentQuestion = null;
                let globalMetadata = { subject: '', chapter: '', lesson: '', board: '', isQuizzable: true, tags: ['cq', 'bn'] };
                let inAnswerSection = false;
                let currentPartLetter = null;
                let currentPartAnswerBuffer = [];
                let questionTextBuffer = [];

                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    if (line.length === 0 && !inAnswerSection) continue;

                    // Handle metadata
                    const metadataMatch = line.match(/^(Subject|Chapter|Lesson|Board|isQuizzable|Tags):\s*(.*)$/i) || 
                                         line.match(/^\[(Subject|Chapter|Lesson|Board|isQuizzable|Tags):\s*(.*?)\]$/i);
                    if (metadataMatch) {
                        const key = metadataMatch[1].toLowerCase();
                        let value = metadataMatch[2].trim();
                        if (key === 'isquizzable') value = value.toLowerCase() === 'true';
                        else if (key === 'tags') value = ['cq', 'bn', ...value.split(',').map(t => t.trim()).filter(t => t && t !== 'cq' && t !== 'bn')];
                        if (currentQuestion) {
                            currentQuestion[key] = value;
                        } else {
                            globalMetadata[key] = value;
                        }
                        continue;
                    }

                    // Detect new question with English or Bangla digits
                    if (/^প্রশ্ন\s+[\d০-৯]+/i.test(line)) {
                        if (currentQuestion) {
                            if (inAnswerSection && currentPartLetter && currentPartAnswerBuffer.length) {
                                const part = currentQuestion.parts.find(p => p.letter === currentPartLetter);
                                if (part) part.answer = currentPartAnswerBuffer.join('\n').trim();
                            }
                            if (currentQuestion.questionText && currentQuestion.parts.length > 0 && currentQuestion.parts.every(p => p.answer)) {
                                if (!isDuplicateQuestion(currentQuestion)) {
                                    newQuestions.push(currentQuestion);
                                } else {
                                    skippedQuestions.push(currentQuestion);
                                }
                            } else {
                                console.warn("Skipping incomplete question:", currentQuestion);
                            }
                        }
                        currentQuestion = {
                            ...globalMetadata,
                            id: Date.now() + Math.floor(Math.random() * 1000),
                            type: 'cq',
                            language: 'bn',
                            questionText: '',
                            image: null,
                            answerimage1: null,
                            answerimage2: null,
                            parts: [],
                            synced: false
                        };
                        inAnswerSection = false;
                        currentPartLetter = null;
                        currentPartAnswerBuffer = [];
                        questionTextBuffer = [];
                        continue;
                    }

                    // Start of answer section
                    if (line.toLowerCase() === 'উত্তর:') {
                        inAnswerSection = true;
                        currentQuestion.questionText = questionTextBuffer.join('\n').trim();
                        questionTextBuffer = [];
                        continue;
                    }

                    if (!inAnswerSection) {
                        // Parse parts with flexible separators and Bangla/English digits
                        const partMatch = line.match(/^([a-d])\s*[\).\s]\s*(.*?)\s*\(([\d০-৯]+)\)\s*$/i);
                        if (partMatch) {
                            if (!currentQuestion) {
                                currentQuestion = {
                                    ...globalMetadata,
                                    id: Date.now() + Math.floor(Math.random() * 1000),
                                    type: 'cq',
                                    language: 'bn',
                                    questionText: '',
                                    image: null,
                                    answerimage1: null,
                                    answerimage2: null,
                                    parts: [],
                                    synced: false
                                };
                            }
                            const partLetter = partMatch[1].toLowerCase();
                            const marks = banglaToNumber(partMatch[3]);
                            currentQuestion.parts.push({ 
                                letter: partLetter, 
                                text: partMatch[2].trim(), 
                                marks: marks, 
                                answer: '', 
                                image: null 
                            });
                            if (i + 1 < lines.length && lines[i + 1].trim() === `[ছবি আছে জন্য অংশ ${partLetter}]`) {
                                if (partLetter === 'c') {
                                    currentQuestion.answerimage1 = '[ছবি আছে জন্য অংশ c]';
                                } else if (partLetter === 'd') {
                                    currentQuestion.answerimage2 = '[ছবি আছে জন্য অংশ d]';
                                }
                                i++;
                            }
                        } else if (!line.startsWith('[ছবি আছে]')) {
                            questionTextBuffer.push(line);
                        }
                    } else {
                        // Parse answer parts with flexible separators
                        const answerPartMatch = line.match(/^([a-d])\s*[\).\s]\s*(.*)/i);
                        if (answerPartMatch) {
                            if (currentPartLetter && currentPartAnswerBuffer.length) {
                                const part = currentQuestion.parts.find(p => p.letter === currentPartLetter);
                                if (part) part.answer = currentPartAnswerBuffer.join('\n').trim();
                            }
                            currentPartLetter = answerPartMatch[1].toLowerCase();
                            currentPartAnswerBuffer = [answerPartMatch[2]];
                        } else if (currentPartLetter && line.trim() !== "") {
                            currentPartAnswerBuffer.push(line);
                        } else if (line.trim() === "" && currentPartLetter) {
                            currentPartAnswerBuffer.push(line);
                        }
                    }
                }

                // Finalize the last question
                if (currentQuestion) {
                    if (inAnswerSection && currentPartLetter && currentPartAnswerBuffer.length) {
                        const part = currentQuestion.parts.find(p => p.letter === currentPartLetter);
                        if (part) part.answer = currentPartAnswerBuffer.join('\n').trim();
                    }
                    if (!currentQuestion.questionText && questionTextBuffer.length) {
                        currentQuestion.questionText = questionTextBuffer.join('\n').trim();
                    }
                    if (currentQuestion.questionText && currentQuestion.parts.length > 0 && currentQuestion.parts.every(p => p.answer)) {
                        if (!isDuplicateQuestion(currentQuestion)) {
                            newQuestions.push(currentQuestion);
                        } else {
                            skippedQuestions.push(currentQuestion);
                        }
                    } else {
                        console.warn("Skipping incomplete last question:", currentQuestion);
                    }
                }

                // Process and upload questions
                if (newQuestions.length > 0) {
                    let successfulUploads = 0;
                    let skippedCount = skippedQuestions.length;
                    let failedUploads = 0;

                    for (let i = 0; i < newQuestions.length; i += CHUNK_SIZE) {
                        const chunk = newQuestions.slice(i, i + CHUNK_SIZE);
                        const chunkResults = await processChunk(chunk);
                        successfulUploads += chunkResults.successful;
                        skippedCount += chunkResults.skipped;
                        failedUploads += chunkResults.failed;
                    }

                    let message = `Processed ${newQuestions.length + skippedCount} questions:`;
                    message += `\n✅ ${successfulUploads} successfully uploaded`;
                    message += `\n🚫 ${skippedCount} duplicates skipped`;
                    message += `\n❌ ${failedUploads} failed to upload`;

                    alert(message);
                    resetFilters();
                    renderQuestionBank();
                    cqInputBn.value = '';
                    document.querySelector('.tab[data-tab="bank"]').click();
                } else if (skippedQuestions.length > 0) {
                    alert(`No new Bangla CQ questions imported. ${skippedQuestions.length} duplicate Bangla CQ questions were skipped.`);
                } else {
                    alert('No valid Bangla CQ questions found. Please check your format.');
                }
            }

            async function parseSQsBn() {
                const text = sqInputBn.value.trim();
                if (!text) {
                    alert('Please enter Bangla short questions to import.');
                    return;
                }

                const blocks = text.split(/(?=\n*\[Subject:|\n*\d+\.\s)/).filter(b => b.trim());
                const newQuestions = [];
                const skippedQuestions = [];
                let currentMetadata = {
                    subject: '',
                    chapter: '',
                    lesson: '',
                    board: '',
                    isQuizzable: true,
                    tags: ['sq', 'bn']
                };

                for (const block of blocks) {
                    const lines = block.split('\n').map(l => l.trim()).filter(l => l);
                    if (!lines.length) continue;

                    if (lines[0].startsWith('[')) {
                        lines.forEach(line => {
                            if (line.startsWith('[Subject:')) currentMetadata.subject = line.replace('[Subject:', '').replace(']', '').trim();
                            else if (line.startsWith('[Chapter:')) currentMetadata.chapter = line.replace('[Chapter:', '').replace(']', '').trim();
                            else if (line.startsWith('[Lesson:')) currentMetadata.lesson = line.replace('[Lesson:', '').replace(']', '').trim();
                            else if (line.startsWith('[Board:')) currentMetadata.board = line.replace('[Board:', '').replace(']', '').trim();
                            else if (line.startsWith('[isQuizzable:')) currentMetadata.isQuizzable = line.replace('[isQuizzable:', '').replace(']', '').trim().toLowerCase() === 'true';
                            else if (line.startsWith('[Tags:')) {
                                const tags = line.replace('[Tags:', '').replace(']', '').trim();
                                currentMetadata.tags = ['sq', 'bn', ...tags.split(',').map(t => t.trim()).filter(t => t && t !== 'sq' && t !== 'bn')];
                            }
                        });
                        continue;
                    }

                    const question = {
                        ...currentMetadata,
                        id: Date.now() + Math.floor(Math.random() * 1000),
                        type: 'sq',
                        language:'bn',
                        question: '',
                        answer: '',
                        image: null,
                        synced: false
                    };

                    let questionTextBuffer = [];
                    let answerTextBuffer = [];
                    let inAnswerSection = false;

                    for (const line of lines) {
                        if (/^\d+\.\s/.test(line) && !inAnswerSection) {
                            questionTextBuffer.push(line.replace(/^\d+\.\s/, '').trim());
                        } else if (line.toLowerCase().startsWith('answer:') || line.toLowerCase().startsWith('উত্তর:')) {
                            inAnswerSection = true;
                            answerTextBuffer.push(line.replace(/^Answer:/i, '').replace(/^উত্তর:/i, '').trim());
                        } else if (inAnswerSection) {
                            answerTextBuffer.push(line);
                        } else if (!inAnswerSection && line.trim()) {
                            questionTextBuffer.push(line);
                        }
                    }

                    question.question = questionTextBuffer.join('\n').trim();
                    question.answer = answerTextBuffer.join('\n').trim();

                    if (question.question && question.answer) {
                        if (!isDuplicateQuestion(question)) {
                            newQuestions.push(question);
                        } else {
                            skippedQuestions.push(question);
                        }
                    } else {
                        console.warn('Skipping incomplete Bangla SQ question:', question);
                    }
                }

                if (newQuestions.length > 0) {
                    let successfulUploads = 0;
                    let skippedCount = skippedQuestions.length;
                    let failedUploads = 0;

                    for (let i = 0; i < newQuestions.length; i += CHUNK_SIZE) {
                        const chunk = newQuestions.slice(i, i + CHUNK_SIZE);
                        const chunkResults = await processChunk(chunk);

                        successfulUploads += chunkResults.successful;
                        skippedCount += chunkResults.skipped;
                        failedUploads += chunkResults.failed;
                    }

                    let message = `Processed ${newQuestions.length + skippedCount} questions:`;
                    message += `\n✅ ${successfulUploads} successfully uploaded`;
                    message += `\n🚫 ${skippedCount} duplicates skipped`;
                    message += `\n❌ ${failedUploads} failed to upload`;

                    alert(message);
                    resetFilters();
                    renderQuestionBank();
                    sqInputBn.value = '';
                    document.querySelector('.tab[data-tab="bank"]').click();
                } else if (skippedQuestions.length > 0) {
                    alert(`No new Bangla SQ questions imported. ${skippedQuestions.length} duplicate Bangla SQ questions were skipped.`);
                } else {
                    alert('No valid Bangla SQ questions found. Please check your format.');
                }
            }

            async function processChunk(chunk) {
                const results = {
                    successful: 0,
                    skipped: 0,
                    failed: 0
                };

                for (const question of chunk) {
                    try {
                        if (isDuplicateQuestion(question)) {
                            results.skipped++;
                            continue;
                        }

                        const success = await saveSingleQuestion(question);

                        if (success) {
                            questionBank.push(question);
                            results.successful++;
                        } else {
                            results.failed++;
                        }
                    } catch (error) {
                        console.error('Error processing question:', error);
                        results.failed++;
                    }
                }

                return results;
            }

            async function saveSingleQuestion(question) {
                if (!supabaseClient) return false;

                try {
                    const formatted = formatQuestionForSupabase(question);
                    const { error } = await supabaseClient
                        .from('questions')
                        .upsert([formatted]);

                    if (error) {
                        if (error.code === '23505') {
                            console.log('Duplicate question skipped:', question.question);
                            return false;
                        }
                        throw error;
                    }

                    question.synced = true;
                    return true;
                } catch (error) {
                    console.error('Error saving question:', error);
                    return false;
                }
            }

            function formatQuestionForSupabase(q) {
                return {
                    id: q.id,
                    type: q.type,
                    language: q.language,
                    subject: q.subject || null,
                    chapter: q.chapter || null,
                    lesson: q.lesson || null,
                    board: q.board || null,
                    is_quizzable: q.isQuizzable,
                    tags: q.tags || [],
                    question: q.question || null,
                    question_text: q.questionText || null,
                    options: q.options || null,
                    correct_answer: q.correctAnswer || null,
                    explanation: q.explanation || null,
                    parts: q.parts || null,
                    answer: q.answer || null,
                    image: q.image || null,
                    answerimage1: q.answerimage1 || null,
                    answerimage2: q.answerimage2 || null
                };
            }
            function renderQuestionBank() {
                questionsContainer.innerHTML = '';
                let filteredQuestions = questionBank.filter(q => {
                    const matchesSearchText = !currentFilters.searchText ||
                        (q.question?.toLowerCase().includes(currentFilters.searchText.toLowerCase())) ||
                        (q.questionText?.toLowerCase().includes(currentFilters.searchText.toLowerCase())) ||
                        (q.answer?.toLowerCase().includes(currentFilters.searchText.toLowerCase())) ||
                        (q.explanation?.toLowerCase().includes(currentFilters.searchText.toLowerCase())) ||
                        (q.parts?.some(p => (p.text?.toLowerCase().includes(currentFilters.searchText.toLowerCase())) || (p.answer?.toLowerCase().includes(currentFilters.searchText.toLowerCase())))) ||
                        q.tags.some(tag => tag.toLowerCase().includes(currentFilters.searchText.toLowerCase()));
                    const matchesSubject = !currentFilters.subject || q.subject === currentFilters.subject;
                    const matchesChapter = !currentFilters.chapter || q.chapter === currentFilters.chapter;
                    const matchesLesson = !currentFilters.lesson || q.lesson === currentFilters.lesson;
                    const matchesType = !currentFilters.type || q.type === currentFilters.type;
                    const matchesBoard = !currentFilters.board || q.board === currentFilters.board;
                    const matchesQuizzable = currentFilters.isQuizzable === '' || q.isQuizzable === (currentFilters.isQuizzable === 'true');
                    const matchesLanguage = !currentFilters.language || q.language === currentFilters.language;
                    return matchesSearchText && matchesSubject && matchesChapter && matchesLesson && matchesType && matchesBoard && matchesQuizzable && matchesLanguage;
                });

                if (filteredQuestions.length === 0) {
                    questionsContainer.innerHTML = '<p>No questions found matching your criteria.</p>';
                    updateStats([]);
                    return;
                }

                filteredQuestions.forEach(q => {
                    const questionEl = document.createElement('div');
                    questionEl.classList.add('question');
                    let contentHtml = '';

                    if (q.type === 'mcq') {
                        contentHtml += `<p><strong>Question:</strong> ${q.question || 'N/A'}</p>`;
                        if (q.image) contentHtml += `<img src="${q.image}" style="max-width: 200px; max-height: 200px; margin-bottom: 10px;">`;
                        if (q.options && Array.isArray(q.options)) {
                            contentHtml += '<ul class="options-list">';
                            q.options.forEach(option => {
                                contentHtml += `<li ${q.correctAnswer && option.label === q.correctAnswer ? 'class="correct"' : ''}>
                                    ${option.text || 'N/A'}
                                    ${option.image ? `<img src="${option.image}" style="max-width: 100px; max-height: 100px; display: block; margin-top: 5px;">` : ''}
                                </li>`;
                            });
                            contentHtml += '</ul>';
                        } else {
                            contentHtml += '<p>No options available</p>';
                        }
                        contentHtml += `<p><strong>Correct Answer:</strong> ${q.correctAnswer ? q.correctAnswer.toUpperCase() : 'N/A'}</p>`;
                        if (q.explanation) contentHtml += `<p><strong>Explanation:</strong> ${q.explanation}</p>`;
                    } else if (q.type === 'cq') {
                        contentHtml += `<p><strong>Question:</strong> ${q.questionText || 'N/A'}</p>`;
                        if (q.image) contentHtml += `<img src="${q.image}" style="max-width: 200px; max-height: 200px; margin-bottom: 10px;">`;
                        if (q.parts && Array.isArray(q.parts)) {
                            contentHtml += '<ul class="options-list">';
                            q.parts.forEach(part => {
                                let partImage = part.image;
                                if (part.letter === 'c' && q.answerimage1 && q.answerimage1 !== '[There is a picture for part c]' && q.answerimage1 !== '[ছবি আছে জন্য অংশ c]') {
                                    partImage = q.answerimage1;
                                } else if (part.letter === 'd' && q.answerimage2 && q.answerimage2 !== '[There is a picture for part d]' && q.answerimage2 !== '[ছবি আছে জন্য অংশ d]') {
                                    partImage = q.answerimage2;
                                }

                                contentHtml += `<li>
                                    <strong>Part ${part.letter?.toUpperCase() || 'N/A'}:</strong> ${part.text || 'N/A'} (Marks: ${part.marks || 'N/A'})<br>
                                    <strong>Answer:</strong> ${part.answer || 'N/A'}
                                    ${partImage ? `<img src="${partImage}" style="max-width: 100px; max-height: 100px; display: block; margin-top: 5px;">` : ''}
                                </li>`;
                            });
                            contentHtml += '</ul>';
                        } else {
                            contentHtml += '<p>No parts available</p>';
                        }
                    } else if (q.type === 'sq') {
                        contentHtml += `<p><strong>Question:</strong> ${q.question || 'N/A'}</p>`;
                        if (q.image) contentHtml += `<img src="${q.image}" style="max-width: 200px; max-height: 200px; margin-bottom: 10px;">`;
                        contentHtml += `<p><strong>Answer:</strong> ${q.answer || 'N/A'}</p>`;
                    }

                    questionEl.innerHTML = `
                        <div class="metadata">
                            <span>Subject: ${q.subject || 'N/A'}</span>
                            <span>Chapter: ${q.chapter || 'N/A'}</span>
                            <span>Lesson: ${q.lesson || 'N/A'}</span>
                            <span>Board: ${q.board || 'N/A'}</span>
                            <span>Type: ${q.type ? q.type.toUpperCase() : 'N/A'}</span>
                            <span>Quizzable: ${q.isQuizzable ? 'Yes' : 'No'}</span>
                            <span>Tags: ${q.tags?.length ? q.tags.join(', ') : 'N/A'}</span>
                        </div>
                        ${contentHtml}
                        <div class="actions">
                            <button class="edit-btn" data-id="${q.id}">Edit</button>
                            <button class="danger delete-btn" data-id="${q.id}">Delete</button>
                        </div>
                    `;
                    questionsContainer.appendChild(questionEl);
                });
                updateStats(filteredQuestions);
            }

            function editQuestion(id) {
                const question = questionBank.find(q => q.id == id);
                if (!question) return;

                editQuestionId.value = question.id;
                questionType.value = question.type || 'mcq';
                questionType.disabled = true;
                setFormType(question.type);
                subjectInput.value = question.subject || '';
                chapterInput.value = question.chapter || '';
                lessonInput.value = question.lesson || '';
                boardInput.value = question.board || '';
                isQuizzableInput.checked = question.isQuizzable !== false;

                if (question.type === 'cq') {
                    questionTextInput.value = question.questionText || '';
                } else {
                    questionTextInput.value = question.question || '';
                }

                if (question.image) {
                    questionImagePreview.src = question.image;
                    questionImagePreview.style.display = 'block';
                    removeQuestionImageBtn.style.display = 'inline-block';
                } else {
                    questionImagePreview.src = '';
                    questionImagePreview.style.display = 'none';
                    removeQuestionImageBtn.style.display = 'none';
                }

                optionInputs.forEach(input => {
                    const optionLetter = input.dataset.option;
                    input.value = '';
                    const marksInput = document.querySelector(`.part-marks[data-option="${optionLetter}"]`);
                    const answerTextarea = document.querySelector(`.part-answer[data-option="${optionLetter}"]`);
                    const imagePreview = document.querySelector(`.option-image-preview[data-option="${optionLetter}"]`);
                    const removeBtn = document.querySelector(`.remove-option-image-btn[data-option="${optionLetter}"]`);
                    const imageUploadInput = document.querySelector(`.option-image-upload-input[data-option="${optionLetter}"]`);

                    if (marksInput) marksInput.value = '';
                    if (answerTextarea) answerTextarea.value = '';

                    imagePreview.src = '';
                    imagePreview.style.display = 'none';
                    removeBtn.style.display = 'none';
                    imageUploadInput.value = '';
                });
                sqAnswerInput.value = '';
                explanationInput.value = '';

                if (question.type === 'mcq') {
                    question.options.forEach(option => {
                        const input = document.querySelector(`.option[data-option="${option.label}"]`);
                        if (input) {
                            input.value = option.text;
                            const imagePreview = document.querySelector(`.option-image-preview[data-option="${option.label}"]`);
                            const removeBtn = document.querySelector(`.remove-option-image-btn[data-option="${option.label}"]`);
                            if (option.image) {
                                imagePreview.src = option.image;
                                imagePreview.style.display = 'block';
                                removeBtn.style.display = 'inline-block';
                            }
                        }
                    });
                    correctAnswerSelect.value = question.correctAnswer || '';
                    explanationInput.value = question.explanation || '';
                } else if (question.type === 'cq') {
                    (question.parts || []).forEach(part => {
                        const textInput = document.querySelector(`.option[data-option="${part.letter}"]`);
                        const marksInput = document.querySelector(`.part-marks[data-option="${part.letter}"]`);
                        const answerTextarea = document.querySelector(`.part-answer[data-option="${part.letter}"]`);
                        const imagePreview = document.querySelector(`.option-image-preview[data-option="${part.letter}"]`);
                        const removeBtn = document.querySelector(`.remove-option-image-btn[data-option="${part.letter}"]`);
                        if (textInput) textInput.value = part.text || '';
                        if (marksInput) marksInput.value = part.marks || '';
                        if (answerTextarea) answerTextarea.value = part.answer || '';

                        if (part.letter === 'c' && question.answerimage1 && question.answerimage1 !== '[There is a picture for part c]' && question.answerimage1 !== '[ছবি আছে জন্য অংশ c]') {
                            imagePreview.src = question.answerimage1;
                            imagePreview.style.display = 'block';
                            removeBtn.style.display = 'inline-block';
                        } else if (part.letter === 'd' && question.answerimage2 && question.answerimage2 !== '[There is a picture for part d]' && question.answerimage2 !== '[ছবি আছে জন্য অংশ d]') {
                            imagePreview.src = question.answerimage2;
                            imagePreview.style.display = 'block';
                            removeBtn.style.display = 'inline-block';
                        } else if (part.image) {
                            imagePreview.src = part.image;
                            imagePreview.style.display = 'block';
                            removeBtn.style.display = 'inline-block';
                        }
                    });
                } else if (question.type === 'sq') {
                    sqAnswerInput.value = question.answer || '';
                }

                tagsInput.value = question.tags ? question.tags.join(', ') : '';
                cancelEditBtn.style.display = 'inline-block';
                document.querySelector('.tab[data-tab="add"]').click();
            }

            async function deleteQuestion(id) {
                if (confirm('Are you sure you want to delete this question?')) {
                    const questionToDelete = questionBank.find(q => q.id == id);
                    if (!questionToDelete) return;

                    if (!supabaseClient) {
                        alert('Supabase is not connected. Cannot delete question from the database.');
                        return;
                    }

                    if (questionToDelete.image) {
                        await deleteImage(questionToDelete.image);
                    }
                    if (questionToDelete.answerimage1 && questionToDelete.answerimage1 !== '[There is a picture for part c]' && questionToDelete.answerimage1 !== '[ছবি আছে জন্য অংশ c]') {
                        await deleteImage(questionToDelete.answerimage1);
                    }
                    if (questionToDelete.answerimage2 && questionToDelete.answerimage2 !== '[There is a picture for part d]' && questionToDelete.answerimage2 !== '[ছবি আছে জন্য অংশ d]') {
                        await deleteImage(questionToDelete.answerimage2);
                    }
                    if (questionToDelete.type === 'mcq' && questionToDelete.options) {
                        for (const opt of questionToDelete.options) {
                            if (opt.image) await deleteImage(opt.image);
                        }
                    } else if (questionToDelete.type === 'cq' && questionToDelete.parts) {
                        for (const part of questionToDelete.parts) {
                            if (part.image) await deleteImage(part.image);
                        }
                    }

                    try {
                        const { error } = await supabaseClient
                            .from('questions')
                            .delete()
                            .eq('id', id);

                        if (error) {
                            console.error('❌ Error deleting question from Supabase:', error);
                            alert('Error deleting question from database. Please try again.');
                        } else {
                            console.log(`✅ Question ${id} deleted from Supabase.`);
                            questionBank = questionBank.filter(q => q.id != id);
                            renderQuestionBank();
                        }
                    } catch (supabaseError) {
                        console.error('❌ Supabase delete operation failed:', supabaseError);
                        alert('Could not delete question from database. Please check your network connection.');
                    }
                }
            }

            async function saveQuestions() {
                if (!supabaseClient) {
                    console.error('Supabase client not available. Cannot save questions.');
                    alert('Supabase is not connected. Cannot save questions to the database.');
                    return;
                }

                const questionsToSync = questionBank.filter(q => !q.synced);

                if (questionsToSync.length === 0) {
                    console.log('No questions to sync.');
                    return;
                }

                try {
                    const formattedQuestions = questionsToSync.map(q => {
                        const base = {
                            id: q.id,
                            type: q.type,
                            subject: q.subject || null,
                            chapter: q.chapter || null,
                            lesson: q.lesson || null,
                            board: q.board || null,
                            is_quizzable: q.isQuizzable,
                            tags: q.tags || [],
                            image: q.image || null,
                            answerimage1: q.answerimage1 || null,
                            answerimage2: q.answerimage2 || null,
                        };

                        if (q.type === 'mcq') {
                            return {
                                ...base,
                                question: q.question,
                                options: q.options,
                                correct_answer: q.correctAnswer,
                                explanation: q.explanation || null,
                                question_text: null,
                                parts: null,
                                answer: null,
                            };
                        } else if (q.type === 'cq') {
                            return {
                                ...base,
                                question_text: q.questionText,
                                parts: q.parts,
                                question: null,
                                options: null,
                                correct_answer: null,
                                explanation: null,
                                answer: null,
                            };
                        } else if (q.type === 'sq') {
                            return {
                                ...base,
                                question: q.question,
                                answer: q.answer,
                                question_text: null,
                                options: null,
                                correct_answer: null,
                                explanation: null,
                                parts: null,
                            };
                        }
                    });

                    const { data, error } = await supabaseClient
                        .from('questions')
                        .upsert(formattedQuestions, { onConflict: 'id' });

                    if (error) {
                        console.error('Error saving questions to Supabase:', error);
                        alert('Failed to save questions to Supabase. Please try again.');
                    } else {
                        console.log('Questions saved successfully:', data);
                        questionsToSync.forEach(q => (q.synced = true));
                    }
                } catch (error) {
                    console.error('Error during saveQuestions:', error);
                    alert('An error occurred while saving questions. Please check the console for details.');
                }
            }

            async function saveQuestion() {
                if (!supabaseClient) {
                    alert('Supabase is not connected. Cannot save question.');
                    return;
                }

                const type = questionType.value;
                if (!type || !questionTextInput.value.trim()) {
                    alert('Please enter a question and select a type.');
                    return;
                }

                const existingQuestion = editQuestionId.value ? questionBank.find(q => q.id == editQuestionId.value) : null;

                const question = {
                    id: editQuestionId.value ? parseInt(editQuestionId.value) : Date.now() + Math.floor(Math.random() * 1000),
                    type,
                    language: 'en',
                    subject: subjectInput.value.trim(),
                    chapter: chapterInput.value.trim(),
                    lesson: lessonInput.value.trim(),
                    board: boardInput.value.trim(),
                    isQuizzable: isQuizzableInput.checked,
                    tags: tagsInput.value.split(',').map(t => t.trim()).filter(t => t),
                    image: null,
                    answerimage1: null,
                    answerimage2: null,
                    explanation: null,
                    synced: false
                };

                if (!question.tags.includes(type)) question.tags.push(type);

                if (questionImageUpload.files.length > 0) {
                    const oldImageUrl = existingQuestion?.image;
                    if (oldImageUrl) await deleteImage(oldImageUrl);
                    questionImagePreview.src = 'Uploading...';
                    const imageUrl = await uploadImage(questionImageUpload.files[0], 'questions');
                    if (imageUrl) {
                        question.image = imageUrl;
                    } else {
                        alert('Failed to upload question image. Please try again.');
                        questionImagePreview.src = '';
                        return;
                    }
                } else if (questionImagePreview.src && questionImagePreview.style.display === 'block') {
                    question.image = questionImagePreview.src;
                } else {
                    const oldImageUrl = existingQuestion?.image;
                    if (oldImageUrl) await deleteImage(oldImageUrl);
                    question.image = null;
                }

                if (type === 'mcq') {
                    question.question = questionTextInput.value.trim();
                    question.explanation = explanationInput.value.trim();
                    const options = [];
                    for (const input of optionInputs) {
                        const optionLetter = input.dataset.option;
                        const text = input.value.trim();
                        const imageUploadInput = document.querySelector(`.option-image-upload-input[data-option="${optionLetter}"]`);
                        const imagePreview = document.querySelector(`.option-image-preview[data-option="${optionLetter}"]`);

                        let optionImage = null;
                        const existingOption = existingQuestion?.options?.find(opt => opt.label === optionLetter);

                        if (imageUploadInput.files.length > 0) {
                            if (existingOption?.image) await deleteImage(existingOption.image);
                            imagePreview.src = 'Uploading...';
                            optionImage = await uploadImage(imageUploadInput.files[0], `options/${question.id}`);
                            if (!optionImage) {
                                alert(`Failed to upload image for option ${optionLetter}. Please try again.`);
                                return;
                            }
                        } else if (imagePreview.src && imagePreview.style.display === 'block') {
                            optionImage = imagePreview.src;
                        } else {
                            if (existingOption?.image) await deleteImage(existingOption.image);
                        }

                        if (text || optionImage) {
                            options.push({
                                label: optionLetter,
                                text: text,
                                image: optionImage
                            });
                        }
                    }
                    if (options.length < 2 || !correctAnswerSelect.value) {
                        alert('Please provide at least 2 options and select a correct answer.');
                        return;
                    }
                    question.options = options;
                    question.correctAnswer = correctAnswerSelect.value;
                    delete question.questionText;
                    delete question.parts;
                    delete question.answer;
                } else if (type === 'cq') {
                    question.questionText = questionTextInput.value.trim();
                    const parts = [];
                    for (const letter of ['a', 'b', 'c', 'd']) {
                        const textInput = document.querySelector(`.option[data-option="${letter}"]`);
                        const marksInput = document.querySelector(`.part-marks[data-option="${letter}"]`);
                        const answerTextarea = document.querySelector(`.part-answer[data-option="${letter}"]`);
                        const imageUploadInput = document.querySelector(`.option-image-upload-input[data-option="${letter}"]`);
                        const imagePreview = document.querySelector(`.option-image-preview[data-option="${letter}"]`);

                        const text = textInput.value.trim();
                        const marks = marksInput.value.trim();
                        const answer = answerTextarea.value.trim();

                        let partImage = null;
                        const existingPart = existingQuestion?.parts?.find(p => p.letter === letter);

                        if (imageUploadInput.files.length > 0) {
                            if (existingPart?.image) await deleteImage(existingPart.image);
                            imagePreview.src = 'Uploading...';
                            partImage = await uploadImage(imageUploadInput.files[0], `parts/${question.id}`);
                            if (!partImage) {
                                alert(`Failed to upload image for part ${letter}. Please try again.`);
                                return;
                            }
                        } else if (imagePreview.src && imagePreview.style.display === 'block') {
                            partImage = imagePreview.src;
                        } else {
                            if (existingPart?.image) await deleteImage(existingPart.image);
                        }

                        if (letter === 'c') {
                            if (partImage) {
                                if (existingQuestion?.answerimage1 && existingQuestion.answerimage1 !== partImage && existingQuestion.answerimage1 !== '[There is a picture for part c]' && existingQuestion.answerimage1 !== '[ছবি আছে জন্য অংশ c]') {
                                    await deleteImage(existingQuestion.answerimage1);
                                }
                                question.answerimage1 = partImage;
                            } else if (existingQuestion?.answerimage1 && existingQuestion.answerimage1 !== '[There is a picture for part c]' && existingQuestion.answerimage1 !== '[ছবি আছে জন্য অংশ c]') {
                                await deleteImage(existingQuestion.answerimage1);
                                question.answerimage1 = null;
                            }
                        }

                        if (letter === 'd') {
                            if (partImage) {
                                if (existingQuestion?.answerimage2 && existingQuestion.answerimage2 !== partImage && existingQuestion.answerimage2 !== '[There is a picture for part d]' && existingQuestion.answerimage2 !== '[ছবি আছে জন্য অংশ d]') {
                                    await deleteImage(existingQuestion.answerimage2);
                                }
                                question.answerimage2 = partImage;
                            } else if (existingQuestion?.answerimage2 && existingQuestion.answerimage2 !== '[There is a picture for part d]' && existingQuestion.answerimage2 !== '[ছবি আছে জন্য অংশ d]') {
                                await deleteImage(existingQuestion.answerimage2);
                                question.answerimage2 = null;
                            }
                        }

                        if (text && marks && answer) {
                            parts.push({ letter, text, marks: parseInt(marks), answer, image: partImage });
                        }
                    }
                    if (parts.length === 0) {
                        alert('Please provide at least one part with question, marks, and answer.');
                        return;
                    }
                    question.parts = parts;
                    delete question.question;
                    delete question.options;
                    delete question.correctAnswer;
                    delete question.answer;
                    delete question.explanation;
                } else if (type === 'sq') {
                    question.question = questionTextInput.value.trim();
                    question.answer = sqAnswerInput.value.trim();
                    if (!question.question || !question.answer) {
                        alert('Please provide both a question and an answer for Short Questions.');
                        return;
                    }
                    delete question.questionText;
                    delete question.options;
                    delete question.correctAnswer;
                    delete question.parts;
                    delete question.explanation;
                }

                if (!editQuestionId.value) {
                    if (isDuplicateQuestion(question)) {
                        alert('This question already exists in the bank. Duplicate questions cannot be added.');
                        return;
                    }
                }

                const index = questionBank.findIndex(q => q.id == editQuestionId.value);
                if (index !== -1) {
                    questionBank[index] = question;
                    console.log('Updated existing question:', question.id);
                } else {
                    questionBank.push(question);
                    console.log('Added new question:', question.id);
                }

                try {
                    await saveQuestions();
                    alert('Question saved successfully!');
                } catch (error) {
                    console.error('Error saving question:', error);
                    alert('Error saving question. Please try again.');
                    return;
                }
                resetQuestionForm();
                renderQuestionBank();
                document.querySelector('.tab[data-tab="bank"]').click();
            }

            function resetQuestionForm() {
                editQuestionId.value = '';
                questionType.value = 'mcq';
                questionType.disabled = false;
                setFormType('mcq');
                subjectInput.value = '';
                chapterInput.value = '';
                lessonInput.value = '';
                boardInput.value = '';
                isQuizzableInput.checked = true;
                questionTextInput.value = '';
                questionImagePreview.src = '';
                questionImagePreview.style.display = 'none';
                removeQuestionImageBtn.style.display = 'none';
                questionImageUpload.value = '';
                optionInputs.forEach(input => {
                    const optionLetter = input.dataset.option;
                    input.value = '';
                    const imagePreview = document.querySelector(`.option-image-preview[data-option="${optionLetter}"]`);
                    const removeBtn = document.querySelector(`.remove-option-image-btn[data-option="${optionLetter}"]`);
                    const marksInput = document.querySelector(`.part-marks[data-option="${optionLetter}"]`);
                    const answerTextarea = document.querySelector(`.part-answer[data-option="${optionLetter}"]`);
                    const optionImageInput = document.querySelector(`.option-image-upload-input[data-option="${optionLetter}"]`);

                    imagePreview.src = '';
                    imagePreview.style.display = 'none';
                    removeBtn.style.display = 'none';
                    if (marksInput) marksInput.value = '';
                    if (answerTextarea) answerTextarea.value = '';
                    if (optionImageInput) optionImageInput.value = '';
                });
                correctAnswerSelect.value = '';
                sqAnswerInput.value = '';
                explanationInput.value = '';
                tagsInput.value = '';
                cancelEditBtn.style.display = 'none';
            }

            function applyFilters() {
                currentFilters = {
                    searchText: searchText.value.trim(),
                    subject: filterSubject.value,
                    chapter: filterChapter.value,
                    lesson: filterLesson.value,
                    type: filterType.value,
                    board: filterBoard.value,
                    isQuizzable: filterQuizzable.value,
                    language: filterLanguage.value
                };
                renderQuestionBank();
            }

            function resetFilters() {
                searchText.value = '';
                filterSubject.value = '';
                filterChapter.value = '';
                filterLesson.value = '';
                filterType.value = '';
                filterBoard.value = '';
                filterQuizzable.value = '';
                filterLanguage.value = '';
                currentFilters = {};
                updateFilters();
                renderQuestionBank();
            }

            function updateStats(questions) {
                totalQuestionsEl.textContent = questions.length;
                const subjects = new Set(questions.map(q => q.subject).filter(s => s));
                subjectsCountEl.textContent = subjects.size;
                const chapters = new Set(questions.map(q => q.chapter).filter(c => c));
                chaptersCountEl.textContent = chapters.size;
                updateDetailedStats(questions);
            }

            function updateDetailedStats(questions) {
                const stats = {};

                questions.forEach(q => {
                    const subject = q.subject || 'Uncategorized Subject';
                    const chapter = q.chapter || 'Uncategorized Chapter';
                    const type = q.type || 'unknown';

                    if (!stats[subject]) {
                        stats[subject] = { mcq: {}, cq: {}, sq: {}, total: 0 };
                    }

                    stats[subject].total++;

                    if (type === 'mcq') {
                        if (!stats[subject].mcq[chapter]) {
                            stats[subject].mcq[chapter] = 0;
                        }
                        stats[subject].mcq[chapter]++;
                    } else if (type === 'cq') {
                        if (!stats[subject].cq[chapter]) {
                            stats[subject].cq[chapter] = 0;
                        }
                        stats[subject].cq[chapter]++;
                    } else if (type === 'sq') {
                        if (!stats[subject].sq[chapter]) {
                            stats[subject].sq[chapter] = 0;
                        }
                        stats[subject].sq[chapter]++;
                    }
                });

                let detailedHtml = '<ul>';
                const sortedSubjects = Object.keys(stats).sort();

                sortedSubjects.forEach(subject => {
                    detailedHtml += `<li><strong>${subject}:</strong> Total Questions: ${stats[subject].total}`;

                    const sortedChaptersMCQ = Object.keys(stats[subject].mcq).sort();
                    if (sortedChaptersMCQ.length > 0) {
                        detailedHtml += ` (MCQ: `;
                        sortedChaptersMCQ.forEach((chapter, index) => {
                            detailedHtml += `${chapter}: ${stats[subject].mcq[chapter]}`;
                            if (index < sortedChaptersMCQ.length - 1) detailedHtml += ', ';
                        });
                        detailedHtml += `)`;
                    }

                    const sortedChaptersCQ = Object.keys(stats[subject].cq).sort();
                    if (sortedChaptersCQ.length > 0) {
                        detailedHtml += ` (CQ: `;
                        sortedChaptersCQ.forEach((chapter, index) => {
                            detailedHtml += `${chapter}: ${stats[subject].cq[chapter]}`;
                            if (index < sortedChaptersCQ.length - 1) detailedHtml += ', ';
                        });
                        detailedHtml += `)`;
                    }

                    const sortedChaptersSQ = Object.keys(stats[subject].sq).sort();
                    if (sortedChaptersSQ.length > 0) {
                        detailedHtml += ` (SQ: `;
                        sortedChaptersSQ.forEach((chapter, index) => {
                            detailedHtml += `${chapter}: ${stats[subject].sq[chapter]}`;
                            if (index < sortedChaptersSQ.length - 1) detailedHtml += ', ';
                        });
                        detailedHtml += `)`;
                    }

                    detailedHtml += `</li>`;
                });

                detailedHtml += '</ul>';
                detailedStatsContent.innerHTML = detailedHtml;
            }

                                                 function updateFilters() {
                                                     // Update Subject dropdown
                                                     const subjects = ['', ...new Set(questionBank.map(q => q.subject).filter(s => s))].sort();
                                                     filterSubject.innerHTML = subjects.map(s => `<option value="${s}" ${currentFilters.subject === s ? 'selected' : ''}>${s || 'All Subjects'}</option>`).join('');

                                                     // Filter chapters by selected subject
                                                     let chaptersFiltered = currentFilters.subject ? 
                                                         questionBank.filter(q => q.subject === currentFilters.subject) : 
                                                         questionBank;

                                                     const chapters = ['', ...new Set(chaptersFiltered.map(q => q.chapter).filter(c => c))].sort();
                                                     filterChapter.innerHTML = chapters.map(c => `<option value="${c}" ${currentFilters.chapter === c ? 'selected' : ''}>${c || 'All Chapters'}</option>`).join('');

                                                     // Filter lessons by selected subject and chapter
                                                     if (currentFilters.subject) {
                                                         chaptersFiltered = chaptersFiltered.filter(q => q.subject === currentFilters.subject);
                                                     }
                                                     if (currentFilters.chapter) {
                                                         chaptersFiltered = chaptersFiltered.filter(q => q.chapter === currentFilters.chapter);
                                                     }

                                                     const lessons = ['', ...new Set(chaptersFiltered.map(q => q.lesson).filter(l => l))].sort();
                                                     filterLesson.innerHTML = lessons.map(l => `<option value="${l}" ${currentFilters.lesson === l ? 'selected' : ''}>${l || 'All Lessons'}</option>`).join('');

                                                     // Update Board dropdown (not filtered by subject/chapter/lesson)
                                                     const boards = ['', ...new Set(questionBank.map(q => q.board).filter(b => b))].sort();
                                                     filterBoard.innerHTML = boards.map(b => `<option value="${b}" ${currentFilters.board === b ? 'selected' : ''}>${b || 'All Boards'}</option>`).join('');

                                                     // Update Quizzable dropdown
                                                     filterQuizzable.value = currentFilters.isQuizzable || '';

                                                     // Update Language dropdown
                                                     filterLanguage.value = currentFilters.language || '';
                                                 }

                                                 // Export questions
                                                 function exportQuestions() {
                                                     const dataStr = JSON.stringify(questionBank, null, 2);
                                                     const blob = new Blob([dataStr], { type: 'application/json' });
                                                     const url = URL.createObjectURL(blob);
                                                     const a = document.createElement('a');
                                                     a.href = url;
                                                     a.download = 'questions-export.json';
                                                     document.body.appendChild(a);
                                                     a.click();
                                                     document.body.removeChild(a);
                                                     URL.revokeObjectURL(url);
                                                 }

                                                 // Import questions
                                                 function importQuestions() {
                                                     if (!supabaseClient) {
                                                         alert('Supabase is not connected. Cannot import questions to the database.');
                                                         return;
                                                     }
                                                     const input = document.createElement('input');
                                                     input.type = 'file';
                                                     input.accept = '.json';
                                                     input.onchange = async e => {
                                                         const file = e.target.files[0];
                                                         if (!file) return;
                                                         const reader = new FileReader();
                                                         reader.onload = async event => {
                                                             try {
                                                                 const importedQuestions = JSON.parse(event.target.result);
                                                                 if (Array.isArray(importedQuestions) && importedQuestions.length) {
                                                                     if (confirm(`Import ${importedQuestions.length} questions? This will add them to your existing bank and skip duplicates.`)) {
                                                                         let newAddedCount = 0;
                                                                         let skippedCount = 0;

                                                                         // Ensure imported questions have unique IDs
                                                                         const processedImportedQuestions = importedQuestions.map(q => ({
                                                                             ...q,
                                                                             id: q.id || (Date.now() + Math.floor(Math.random() * 1000)),
                                                                             synced: false
                                                                         }));

                                                                         for (const newQ of processedImportedQuestions) {
                                                                             if (!isDuplicateQuestion(newQ)) {
                                                                                 const existingIndex = questionBank.findIndex(q => q.id === newQ.id);
                                                                                 if (existingIndex !== -1) {
                                                                                     // Update existing question
                                                                                     questionBank[existingIndex] = newQ;
                                                                                 } else {
                                                                                     // Add new question
                                                                                     questionBank.push(newQ);
                                                                                     newAddedCount++;
                                                                                 }
                                                                             } else {
                                                                                 skippedCount++;
                                                                             }
                                                                         }

                                                                         await saveQuestions(); // Save to Supabase
                                                                         questionBank = await loadQuestions(); // Reload from Supabase
                                                                         resetFilters();
                                                                         renderQuestionBank();
                                                                         alert(`Questions imported successfully! Added ${newAddedCount} new questions. Skipped ${skippedCount} duplicate questions.`);
                                                                     }
                                                                 } else {
                                                                     alert('No valid questions found in the file.');
                                                                 }
                                                             } catch (error) {
                                                                 console.error('Error importing questions:', error);
                                                                 alert('Error importing questions. Check the file format or Supabase connection.');
                                                             }
                                                         };
                                                         reader.readAsText(file);
                                                     };
                                                     input.click();
                                                 }

                                                 // Image upload handlers
                                                 questionImageUpload.addEventListener('click', function() { this.value = ''; });
                                                 questionImageUpload.addEventListener('change', function(e) {
                                                     const file = e.target.files[0];
                                                     if (file) {
                                                         if (!file.type.match('image.*')) {
                                                             alert('Please select an image file.');
                                                             this.value = '';
                                                             return;
                                                         }
                                                         if (file.size > 2 * 1024 * 1024) { // 2MB limit
                                                             alert('Image size should be less than 2MB.');
                                                             this.value = '';
                                                             return;
                                                         }
                                                         const reader = new FileReader();
                                                         reader.onload = event => {
                                                             questionImagePreview.src = event.target.result;
                                                             questionImagePreview.style.display = 'block';
                                                             removeQuestionImageBtn.style.display = 'inline-block';
                                                         };
                                                         reader.readAsDataURL(file);
                                                     }
                                                 });

                                                 removeQuestionImageBtn.addEventListener('click', async function() {
                                                     const currentQuestionId = editQuestionId.value;
                                                     const existingQuestion = questionBank.find(q => q.id == currentQuestionId);
                                                     if (existingQuestion && existingQuestion.image) {
                                                         await deleteImage(existingQuestion.image);
                                                         existingQuestion.image = null;
                                                         existingQuestion.synced = false;
                                                         await saveQuestions();
                                                     }
                                                     questionImagePreview.src = '';
                                                     questionImagePreview.style.display = 'none';
                                                     this.style.display = 'none';
                                                     questionImageUpload.value = '';
                                                 });

                                                 optionImageUploadInputs.forEach(input => {
                                                     input.addEventListener('click', function() { this.value = ''; });
                                                     input.addEventListener('change', function(e) {
                                                         const file = e.target.files[0];
                                                         const optionLetter = this.dataset.option;
                                                         const preview = document.querySelector(`.option-image-preview[data-option="${optionLetter}"]`);
                                                         const removeBtn = document.querySelector(`.remove-option-image-btn[data-option="${optionLetter}"]`);
                                                         if (file) {
                                                             if (!file.type.match('image.*')) {
                                                                 alert('Please select an image file.');
                                                                 this.value = '';
                                                                 return;
                                                             }
                                                             if (file.size > 2 * 1024 * 1024) {
                                                                 alert('Image size should be less than 2MB.');
                                                                 this.value = '';
                                                                 return;
                                                             }
                                                             const reader = new FileReader();
                                                             reader.onload = event => {
                                                                 preview.src = event.target.result;
                                                                 preview.style.display = 'block';
                                                                 removeBtn.style.display = 'inline-block';
                                                             };
                                                             reader.readAsDataURL(file);
                                                         }
                                                     });
                                                 });

                                                 removeOptionImageBtns.forEach(btn => {
                                                     btn.addEventListener('click', async function() {
                                                         const optionLetter = this.dataset.option;
                                                         const preview = document.querySelector(`.option-image-preview[data-option="${optionLetter}"]`);
                                                         const input = document.querySelector(`.option-image-upload-input[data-option="${optionLetter}"]`);

                                                         const currentQuestionId = editQuestionId.value;
                                                         const existingQuestion = questionBank.find(q => q.id == currentQuestionId);

                                                         if (existingQuestion) {
                                                             if (existingQuestion.type === 'mcq') {
                                                                 const existingOption = existingQuestion.options?.find(opt => opt.label === optionLetter);
                                                                 if (existingOption && existingOption.image) {
                                                                     await deleteImage(existingOption.image);
                                                                     existingOption.image = null;
                                                                     existingQuestion.synced = false;
                                                                     await saveQuestions();
                                                                 }
                                                             } else if (existingQuestion.type === 'cq') {
                                                                 const existingPart = existingQuestion.parts?.find(p => p.letter === optionLetter);
                                                                 if (existingPart && existingPart.image) {
                                                                     await deleteImage(existingPart.image);
                                                                     existingPart.image = null;
                                                                     existingQuestion.synced = false;
                                                                     await saveQuestions();
                                                                 }
                                                                 // Handle specific answer images for CQ
                                                                 if (optionLetter === 'c' && existingQuestion.answerimage1 && existingQuestion.answerimage1 !== '[There is a picture for part c]' && existingQuestion.answerimage1 !== '[ছবি আছে জন্য অংশ c]') {
                                                                     await deleteImage(existingQuestion.answerimage1);
                                                                     existingQuestion.answerimage1 = null;
                                                                     existingQuestion.synced = false;
                                                                     await saveQuestions();
                                                                 }
                                                                 if (optionLetter === 'd' && existingQuestion.answerimage2 && existingQuestion.answerimage2 !== '[There is a picture for part d]' && existingQuestion.answerimage2 !== '[ছবি আছে জন্য অংশ d]') {
                                                                     await deleteImage(existingQuestion.answerimage2);
                                                                     existingQuestion.answerimage2 = null;
                                                                     existingQuestion.synced = false;
                                                                     await saveQuestions();
                                                                 }
                                                             }
                                                         }

                                                         preview.src = '';
                                                         preview.style.display = 'none';
                                                         this.style.display = 'none';
                                                         input.value = '';
                                                     });
                                                 });

                                                 // Attach event listeners
                                                 function attachEventListeners() {
                                                     console.log("🔄 Attaching event listeners...");

                                                     // Existing English question listeners
                                                     parseBtn.addEventListener('click', parseMCQs);
                                                     clearImportBtn.addEventListener('click', () => mcqInput.value = '');
                                                     parseCqBtn.addEventListener('click', parseCQs);
                                                     clearCqBtn.addEventListener('click', () => cqInput.value = '');
                                                     parseSqBtn.addEventListener('click', parseSQs);
                                                     clearSqBtn.addEventListener('click', () => sqInput.value = '');

                                                     // Bangla question listeners
                                                     parseBtnBn.addEventListener('click', parseMCQsBn);
                                                     clearImportBtnBn.addEventListener('click', () => mcqInputBn.value = '');
                                                     parseCqBtnBn.addEventListener('click', parseCQsBn);
                                                     clearCqBtnBn.addEventListener('click', () => cqInputBn.value = '');
                                                     parseSqBtnBn.addEventListener('click', parseSQsBn);
                                                     clearSqBtnBn.addEventListener('click', () => sqInputBn.value = '');

                                                     saveQuestionBtn.addEventListener('click', saveQuestion);
                                                     cancelEditBtn.addEventListener('click', resetQuestionForm);
                                                     applyFiltersBtn.addEventListener('click', applyFilters);
                                                     resetFiltersBtn.addEventListener('click', resetFilters);
                                                     exportBtn.addEventListener('click', exportQuestions);
                                                     importBtn.addEventListener('click', importQuestions);

                                                     filterSubject.addEventListener('change', () => {
                                                         currentFilters.subject = filterSubject.value;
                                                         currentFilters.chapter = '';
                                                         currentFilters.lesson = '';
                                                         updateFilters();
                                                         renderQuestionBank();
                                                     });

                                                     filterChapter.addEventListener('change', () => {
                                                         currentFilters.chapter = filterChapter.value;
                                                         currentFilters.lesson = '';
                                                         updateFilters();
                                                         renderQuestionBank();
                                                     });

                                                     filterLesson.addEventListener('change', () => {
                                                         currentFilters.lesson = filterLesson.value;
                                                         renderQuestionBank();
                                                     });

                                                     filterType.addEventListener('change', () => {
                                                         currentFilters.type = filterType.value;
                                                         renderQuestionBank();
                                                     });

                                                     filterBoard.addEventListener('change', () => {
                                                         currentFilters.board = filterBoard.value;
                                                         renderQuestionBank();
                                                     });

                                                     filterQuizzable.addEventListener('change', () => {
                                                         currentFilters.isQuizzable = filterQuizzable.value;
                                                         renderQuestionBank();
                                                     });

                                                     filterLanguage.addEventListener('change', () => {
                                                         currentFilters.language = filterLanguage.value;
                                                         renderQuestionBank();
                                                     });

                                                     questionType.addEventListener('change', () => setFormType(questionType.value));

                                                     questionsContainer.addEventListener('click', e => {
                                                         if (e.target.classList.contains('edit-btn')) {
                                                             e.preventDefault();
                                                             editQuestion(e.target.dataset.id);
                                                         } else if (e.target.classList.contains('delete-btn')) {
                                                             e.preventDefault();
                                                             deleteQuestion(e.target.dataset.id);
                                                         }
                                                     });

                                                     console.log("✅ All event listeners attached successfully");
                                                 }

                                                 // Initialize the app
            async function init() {
                try {
                    console.log("🔄 Starting app initialization...");
                    const supabaseConnected = await initSupabase();

                    if (supabaseConnected) {
                        console.log("🔄 Loading questions from Supabase...");
                        questionBank = await loadQuestions();
                    } else {
                        console.error("Application cannot proceed without Supabase connection.");
                        return;
                    }

                    console.log("🔄 Rendering question bank...");
                    renderQuestionBank();
                    console.log("🔄 Updating stats...");
                    // Pass questionBank to updateStats
                    updateStats(questionBank);
                    console.log("🔄 Updating filters...");
                    updateFilters();
                    console.log("🔄 Attaching event listeners...");
                    attachEventListeners();
                    console.log("🔄 Setting form type...");
                    setFormType('mcq');
                    console.log("✅ App initialized successfully!");
                } catch (error) {
                    console.error("❌ Error initializing app:", error);
                    alert("Error initializing the application. Please check the console for details.");
                }
            }

                                                 init().catch(console.error);
        }
    });
                </script>
            </body>
            </html>

            
